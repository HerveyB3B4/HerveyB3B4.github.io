{"meta":{"title":"Hervey's Blog","subtitle":"","description":"","author":"Hervey","url":"http://herveyb3b4.github.io","root":"/"},"pages":[{"title":"categories","date":"2023-10-30T11:36:37.000Z","updated":"2023-10-30T18:29:20.450Z","comments":true,"path":"categories/index.html","permalink":"http://herveyb3b4.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2023-09-22T16:00:00.000Z","updated":"2025-03-02T06:01:46.125Z","comments":true,"path":"about/index.html","permalink":"http://herveyb3b4.github.io/about/index.html","excerpt":"","text":"欢迎大佬们参观我的 Blog ! About Me本人浙江工业大学软件工程专业本科生在读，一个前 OIer&#x2F;ACMer、CTFer，目前专注于智能汽车竞赛，技术栈偏向前端应用开发 (Vue.js) 与嵌入式软件开发 (C 为主) ，后端应用开发 (Java、Python)。 About Blog随缘更新，主要记录一些我的学习体会和一些乱搞经历(?)"},{"title":"tags","date":"2023-10-30T11:36:49.000Z","updated":"2023-10-30T18:29:20.460Z","comments":true,"path":"tags/index.html","permalink":"http://herveyb3b4.github.io/tags/index.html","excerpt":"","text":""},{"title":"Links","date":"2023-10-30T23:59:14.000Z","updated":"2023-10-31T00:00:49.180Z","comments":true,"path":"links/index.html","permalink":"http://herveyb3b4.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"《30天自制操作系统》学习笔记 day1 - 机器语言与汇编语言","slug":"OSASK/OSASK-day1","date":"2025-03-02T04:56:52.000Z","updated":"2025-03-02T09:33:59.993Z","comments":true,"path":"2025/03/02/OSASK/OSASK-day1/","link":"","permalink":"http://herveyb3b4.github.io/2025/03/02/OSASK/OSASK-day1/","excerpt":"false","text":"十年前的读物刚翻开这本书就被灰尘扑了一脸，看来这本书真的有些年代了 第一个程序 - 机器语言实现 hello, world今天的任务是让计算机识别我们写的代码，我们知道高级语言 (C&#x2F;C++、Java、Python 等) 是不能够直接在裸机上运行的，需要经过编译转为二进制程序运行或使用解释器运行，特别的，Java 程序需要编译成为 Java 字节码，再通过 Java 虚拟机 (JVM) 运行，因此，在没有任何编译器程序、仅有裸机的情况下，只有低级语言能够直接在裸机上运行。 书里首先给出了一个二进制程序作为引入，作为一个 21 世纪 20 年代 (现在是 2025 年) 的程序员，我选择使用 Visual Studio Code 搭配 Hex Editor 插件编写程序 helloos.img（作为一个前 CTFer，我也强烈安利 010 Editor、Win Hex 等软件）。 好吧，感觉这样写要写半天还容易错，还是用脚本写程序吧… (事实证明就算用脚本也有可能写错) gen.py12345678910111213141516file = open(&#x27;helloos.img&#x27;, &#x27;wb&#x27;)i = 0while i &lt; 0x168000: if i == 0: text = b&#x27;\\xeb\\x4e\\x90\\x48\\x45\\x4c\\x4c\\x4f\\x49\\x50\\x4c\\x00\\x02\\x01\\x01\\x00\\x02\\xe0\\x00\\x40\\x0b\\xf0\\x09\\x00\\x12\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x40\\x0b\\x00\\x00\\x00\\x00\\x29\\xff\\xff\\xff\\xff\\x48\\x45\\x4c\\x4c\\x4f\\x2d\\x4f\\x53\\x20\\x20\\x20\\x46\\x41\\x54\\x31\\x32\\x20\\x20\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xb8\\x00\\x00\\x8e\\xd0\\xbc\\x00\\x7c\\x8e\\xd8\\x8e\\xc0\\xbe\\x74\\x7c\\x8a\\x04\\x83\\xc6\\x01\\x3c\\x00\\x74\\x09\\xb4\\x0e\\xbb\\x0f\\x00\\xcd\\x10\\xeb\\xee\\xf4\\xeb\\xfd\\x0a\\x0a\\x68\\x65\\x6c\\x6c\\x6f\\x2c\\x20\\x77\\x6f\\x72\\x6c\\x64\\x0a\\x00\\x00\\x00\\x00\\x00&#x27; elif i == 0x1FE: text = b&#x27;\\x55\\xaa\\xf0\\xff\\xff&#x27; elif i == 0x1400: text = b&#x27;\\xf0\\xff\\xff&#x27; else: text = b&#x27;\\x00&#x27; file.write(text) i += len(text)file.close() 生成 helloos.img 之后，使用作者提供的工具链（在这里下载），将其装载到 qemu 之中，就能够 顺利地 看到 hello, world 字样了。 使用汇编语言实现 hello, world 作者作者 你的机器语言确实很强 但还是太吃操作了 有没有什么简单又清晰的语言推荐一下 有的朋友，有的 像这么简单的语言还有一种 就是 汇编语言 为了提高代码的可读性和持续性，作者介绍了汇编语言实现 hello, world 的方式。 第一种实现方式其实还是机器语言的直译： helloos.nas12345678910111213141516171819202122DB 0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4fDB 0x49, 0x50, 0x4c, 0x00, 0x02, 0x01, 0x01, 0x00DB 0x02, 0xe0, 0x00, 0x40, 0x0b, 0xf0, 0x09, 0x00DB 0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00DB 0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x29, 0xffDB 0xff, 0xff, 0xff, 0x48, 0x45, 0x4c, 0x4c, 0x4fDB 0x2d, 0x4f, 0x53, 0x20, 0x20, 0x20, 0x46, 0x41DB 0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00RESB 16DB 0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7cDB 0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8aDB 0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09DB 0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xebDB 0xee, 0xf4, 0xeb, 0xfd, 0x0a, 0x0a, 0x68, 0x65DB 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72DB 0x6c, 0x64, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00RESB 368DB 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaaDB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00RESB 4600DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00RESB 1469432 依旧和机器语言一样不具有可读性，不过至少能够在一个屏幕上显示了 ) 第二种实现方式则更具有可读性，更像一个“程序”了 helloos.nas12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849; hello-os; TAB=4; 以下这段是标准AFT2格式软盘专用的代码 DB 0xeb, 0x4e, 0x90 DB &quot;HELLOIPL&quot; ; 启动区的名称可以是任意的字符串（8字节） DW 512 ; 每个扇区（sector）的大小（必须为512字节） DB 1 ; 簇（cluster）的大小（必须为1个扇区） DW 1 ; FAT的起始位置（一般从第一个扇区开始） DB 2 ; FAT的个数（必须为2） DW 224 ; 根目录的大小（一般设成224项） DW 2880 ; 该磁盘的大小（必须是2880扇区） DB 0xf0 ; 磁盘的种类（必须是0xf0） DW 9 ; FAT的长度（必须是9扇区） DW 18 ; 1个磁道（track）有几个扇区 DW 2 ; 磁头数（必须是2） DD 0 ; 不使用分区，必须是0 DD 2880 ; 重写一次磁盘大小 DB 0,0,0x29 ; 意义不明，固定 DD 0xffffffff ; （可能是）卷标号码 DB &quot;HELLO-OS &quot; ; 磁盘的名称（11字节） DB &quot;FAT12 &quot; ; 磁盘格式名称（8字节） RESB 18 ; 先空出18字节; 程序主体 DB 0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c DB 0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a DB 0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09 DB 0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb DB 0xee, 0xf4, 0xeb, 0xfd; 信息显示部分 DB 0x0a, 0x0a ; 2个换行 DB &quot;hello, world&quot; DB 0x0a ; 换行 DB 0 RESB 0x1fe-$ ; 填写0x00,直到 0x001fe DB 0x55, 0xaa; 以下是启动区以外部分的输出 DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB 4600 DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB 1469432 一些感受就这样，第一天的学习在大段的的十六进制码中结束了，说说我的感受吧。 硬件发展更迭好快这本书里使用 软盘 装载操作系统，“这是什么？”或许是大部分出生在21世纪的人（包括我）看到这两个字的第一反应，毕竟我们只在保存按钮和一些视频中看见过软盘的样貌，现在容量更大、存取速度更快的存储设备已经完全取代了软盘、光盘等等媒介。 在我们的父母甚至祖父母那一辈却不然，他们经历了计算机在国内引进和发展的过程，亲眼见证了计算机体积的缩小，见证了制造技术的不断改进，见证了移动设备的兴起，或许他们读这本书的感受会和我们不一样。 而在我们之后出生的人，他们接触到的是一个高度发展的信息时代，旧的设备几乎被完全淘汰，新的设备不断更迭，很多人甚至不会还使用电脑就会使用手机了（其实我们这辈就有），他们又会如何理解和认识软盘之类的设备， 又会如何看待这些接近硬件层面的技术呢？ 低级语言好麻烦今天这三个程序的编写（仅仅只是显示一个 Hello, world ）就耗费了一下午时间，而且还是在有完整工具链和现代化工具（甚至使用 Python 脚本辅助）的情况下实现的，很难想象在半个多世纪以前，科学家们是如何一步步实现如此庞大的计算机系统的，又是如何调试运行的。 学习这些底层技术知识，重走来时路，或许是我们感受前人智慧的一种好方法，万一有一天我的经历也会成为他人阅读的历史呢？","categories":[{"name":"《30天自制操作系统》学习笔记","slug":"《30天自制操作系统》学习笔记","permalink":"http://herveyb3b4.github.io/categories/%E3%80%8A30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://herveyb3b4.github.io/tags/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"《30天自制操作系统》学习笔记 day0 - 开个新坑","slug":"OSASK/OSASK-day0","date":"2025-03-01T14:52:36.000Z","updated":"2025-03-02T04:58:16.969Z","comments":true,"path":"2025/03/01/OSASK/OSASK-day0/","link":"","permalink":"http://herveyb3b4.github.io/2025/03/01/OSASK/OSASK-day0/","excerpt":"false","text":"我回来啦！鸽子回笼了 发现上一次更新还是在去年的 4 月份，这个博客也是荒废了好一段时间了。 去年确实有些忙，尤其是上学期的课表，几乎完全无法挤出时间做一些自己的事情，不过偶然之间看到 基本不动的 书架上有一本借来的 《 30 天自制操作系统》。 正好这学期有一门操作系统课，也借着这次机会完成一下小学时立下的一个小目标：读完这本七百多页的“板砖”（在当时来说这本书确实是这样遥不可及的）。 不过这本书已经是十多年前的读物了，很多编程环境已经不再适用于现在的系统环境了，估计会踩很多的坑，至于能不能走到最后，请拭目以待。 最后，就祝我自己能够成功吧！ :-)","categories":[{"name":"《30天自制操作系统》学习笔记","slug":"《30天自制操作系统》学习笔记","permalink":"http://herveyb3b4.github.io/categories/%E3%80%8A30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://herveyb3b4.github.io/tags/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"0329 CTF通识课测试1 WriteUp","slug":"CyberSecurity/CTF/Test-0329-WriteUp","date":"2024-04-07T08:54:32.000Z","updated":"2025-03-02T06:28:03.826Z","comments":true,"path":"2024/04/07/CyberSecurity/CTF/Test-0329-WriteUp/","link":"","permalink":"http://herveyb3b4.github.io/2024/04/07/CyberSecurity/CTF/Test-0329-WriteUp/","excerpt":"false","text":"1-tailhint其实就在题目里… 用 010Editor 打开图片，flag 就在文件尾 2-goose考点: Exif 隐写 右键 &gt;&gt; 属性 &gt;&gt; 详细信息 可以看到 flag 在 来源 &gt; 作者 栏 3-lsb考点: lsb 隐写 使用工具: StegSolve.jar 1java -jar Stegsolve.jar 使用StegSolve打开 1_lsb.png 文件， Analyse &gt; Data Extract ，勾选 Red 0 , Green 0 , Blue 0 , LSB First 点击 Preview 获得 flag 4-polar-light考点: png 长宽爆破 使用 010Editor 获得 png 文件的 CRC 校验码 使用如下脚本爆破 png 文件的真实长宽 123456789101112131415161718import osimport binasciiimport struct#文件名filename = &quot;4.png&quot;#图片当前CRC(29-32位)CRC = 0x2EE0E28Ecrcbp = open(filename, &quot;rb&quot;).read()for i in range(2000): for j in range(2000): data = crcbp[12:16] + \\ struct.pack(&#x27;&gt;i&#x27;, i)+struct.pack(&#x27;&gt;i&#x27;, j)+crcbp[24:29] crc32 = binascii.crc32(data) &amp; 0xffffffff if (crc32 == CRC): print(i, j) print(&#x27;hex:&#x27;, hex(i), hex(j)) 得到png的真实尺寸 1234┌──(hervey㉿Hervey)-[/mnt/c/Users/hervey/Downloads]└─$ python3 ./calc_pic_size.py952 490hex: 0x3b8 0x1ea 替换掉原来的长宽值后打开图片即可获得 flag 5-spring使用 010Editor 打开文件，观察后发现文件倒置了 使用如下脚本还原 png 文件 123with open(&#x27;5.png&#x27;, &#x27;rb&#x27;) as f: with open(&#x27;real.png&#x27;, &#x27;wb&#x27;) as g: g.write(f.read()[::-1]) 打开还原后的图片即可获得 flag 6-bridge使用 010 Editor 打开 6.png 发现后面有一段”冗余”内容 binwalk 一下看看 123456789101112131415┌──(hervey㉿Hervey)-[/mnt/c/Users/hervey/Downloads/6]└─$ binwalk ./6.jpgDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.0230 0x1E TIFF image data, big-endian, offset of first image directory: 8332 0x14C JPEG image data, JFIF standard 1.029499 0x251B JPEG image data, JFIF standard 1.0221682 0x54B2 Copyright string: &quot;Copyright (c) 1998 Hewlett-Packard Company&quot;809662 0xC5ABE JPEG image data, JFIF standard 1.02809692 0xC5ADC TIFF image data, big-endian, offset of first image directory: 8809994 0xC5C0A JPEG image data, JFIF standard 1.02817885 0xC7ADD JPEG image data, JFIF standard 1.02828791 0xCA577 Copyright string: &quot;Copyright (c) 1998 Hewlett-Packard Company&quot; 可以发现在 jpg 文件后还藏了一个 jpg 文件 使用 foremost 命令分离文件 1234┌──(hervey㉿Hervey)-[/mnt/c/Users/hervey/Downloads/6]└─$ foremost ./6.jpgProcessing: ./6.jpg|*| 从分离出的图片中可获得 flag 7-nopassword考察内容: zip伪加密 使用工具偷懒工具: 7zip 直接用 7zip 解压即可 修改 5D 位的 09 为 00 即可无密码进行解压得到 flag.txt ，进而获得 flag 8-birthday考察内容: zip密码爆破 根据题目提示可猜测密码是数字(但是不确定几位)，使用 John 进行爆破 123456789101112131415161718┌──(hervey㉿Hervey)-[/mnt/c/Users/hervey/Downloads]└─$ zip2john 8.zip &gt; 8.hash┌──(hervey㉿Hervey)-[/mnt/c/Users/hervey/Downloads]└─$ john 8.hashUsing default input encoding: UTF-8Loaded 1 password hash (ZIP, WinZip [PBKDF2-SHA1 512/512 AVX512BW 16x])Cost 1 (HMAC size) is 47 for all loaded hashesWill run 16 OpenMP threadsProceeding with single, rules:SinglePress &#x27;q&#x27; or Ctrl-C to abort, almost any other key for statusAlmost done: Processing the remaining buffered candidate passwords, if any.Proceeding with wordlist:/usr/share/john/password.lstProceeding with incremental:ASCII040508 (8.zip/flag.txt)1g 0:00:00:01 DONE 3/3 (2024-04-07 00:02) 0.8333g/s 314803p/s 314803c/s 314803C/s batow1..mcfarsUse the &quot;--show&quot; option to display all of the cracked passwords reliablySession completed. 得到密码为 040508 解压后打开 flag.txt 即可获得 flag 9-manyzip解压文件后可以发现有很多 zip 文件，每个文件里都有一个 txt 文件，尝试使用如下脚本解压文件 123for file in *.zip; do unzip &quot;$file&quot; -d .done 然后使用 strings 命令寻找 flag 123┌──(hervey㉿Hervey)-[/mnt/c/Users/hervey/Downloads/manyzip]└─$ strings *.txt | grep StingerStinger&#123;dfc2e6b5-9f14-4321-a961-2ef0e756d3b7&#125; 10-baseXX打开 txt 文件，发现这样一段文字 1;fl_kB4Z+11G^q!2Ig;Q/Mpur1bCO=2E!-I@Q-+q2.L&amp;P2`&lt;L&amp;0k&lt;$qI/ 使用 Base85 解码获得 flag 11-baseN顾打开 txt 文件，发现这样一段文字 1Vm0xNFUxUXhWWGxVYTJoVVlteEthRlZxVG05alZteDBUbFU1VDFKc1NucFdWM014WVRBeFdHVklhRnBXUlRVelZqSjRWMDVzU25WUmJHaFlVMFZLYUZaR1VrTk9SbHBYVm01U2ExSXdXbGhWYkdRelpERlplRmt6YUZSaGVsWlhWRlpvUTFSc1dYcFJhemxoVmpOb00xa3dXbE5YUlRGWFkwVTFWMVpGV2pSV2JYaFRVakZSZUZOclpGaFdSbFU1 使用 Base64 连续解码 6 次获得 flag 12-流量考察内容: 流量分析 使用工具: Wireshark 使用 Wireshark 打开 ftp.pcapng, Ctrl + F ，选择 分组字节流 、 字符串 查找 Stinger 即可获得 flag 13-流量2考察内容: 流量分析 使用工具: Wireshark 使用 Wireshark 打开 13.pcapng, 这类问题有个技巧，一般情况下 flag 都藏在 HTTP&#x2F;OK 附近，这里也不例外，发现上传了一张 jpg 文件，找到那一段 jpg 文件 右键 &gt;&gt; 显示分组字节... 即可获得 flag 14-word-frequency考察内容: 词频统计 使用工具: quipqiup 把文本内容扔进去分析一下，flag 在最后 120 -1.380Zhejiang University of technology is the first crovincial and ministerial jointly built university in the eastern coastal region, the first leading university of the national Higher education innovation ability enhancement clan (2011 clan) Collaborative innovation Center, and the first key construction university in Zhejiang crovince. it is located in Hangzhou, a famous historical and cultural city in China and a scenic tourist destination. the school was founded in 1953, and its credecessor can be traced back to the Zhejiang Middle industrial school founded in 1910. it has gone through various stages of develocment, including Hangzhou Chemical school, Zhejiang Chemical Vocational school, Zhejiang institute of Chemical technology, and Zhejiang institute of technology. in 1993, it was renamed Zhejiang University of technology. the school has three camcuses, namely Chaohui, cingfeng, and Moganshan, covering an area of 3333 acres. it has 26 secondary colleges and 1 decartment, as well as an indecendent college - Zhijiang College. there are currently 20536 full-time undergraduate students, 14561 graduate students of various tyces, and 1037 international students on camcus. there are 3392 faculty members in school, including 2486 full-time teachers, including 5 academicians of the Cae Member, 1 academician of the Cas Member, 11 scecial excerts of Zhejiang crovince, 4 distinguished crofessors of Changjiang scholars of the Ministry of education, 7 winners of the national science fund for distinguished Young scholars, 13 leading talents of the national &quot;ten thousand talents crogram&quot;, 3 national famous teachers, 6 young Changjiang scholars of the Ministry of education, 14 winners of the national science fund for distinguished Young scholars, 3 young toc talents of the national &quot;ten thousand talents crogram&quot;, 10 young and middle-aged excerts with outstanding contributions at the national level, and 11 candidates of the &quot;ten Million talents crogram&quot; of the Ministry of Human Resources and social security. the school adheres to the fundamental task of cultivating virtue and talents, with toc-notch innovative talents as the guide, advanced acclied talents as the main body, and comcound talents as the characteristics, vigorously cultivating industry elites and leading talents with comcrehensive develocment in morality, intelligence, chysical fitness, aesthetics, and labor, rich catriotism, international cerscective, innovative scirit, and cractical ability. since its establishment, the school has trained and delivered over 300000 outstanding talents of various tyces to the country. there are currently 63 undergraduate enrollment majors, covering 12 categories including chilosochy, economics, law, education, literature, science, engineering, agriculture, medicine, management, art, and interdisciclinary studies. there are 13 doctoral degree authorization coints in first level disciclines, 2 doctoral crofessional degree authorization categories, 30 master&#x27;s degree authorization coints in first level disciclines, 3 master&#x27;s degree authorization coints in second level disciclines that are not covered by first level disciclines, 22 master&#x27;s crofessional degree authorization categories, and 13 costdoctoral mobile stations established. nine disciclines, including chemistry, engineering, materials science, environmental science and ecology, agricultural science, biology and biochemistry, comcuter science, charmacology and toxicology, and general social science, have entered the toc 1% of the global esi. among them, two disciclines, including chemistry and engineering, have entered the toc 1 ‰ of the global esi. the school adheres to serving the major needs of national and regional develocment as its own resconsibility, and focuses on strengthening the strategic layout of the cooceration network between government, industry, academia, research and acclication. there are currently 10 national level research clatforms and 69 crovincial and ministerial level research clatforms. the school has won more than 800 national and crovincial-level scientific research awards, including 24 national science and technology awards, ranking among the toc 40 universities in China in terms of the number of awards; 11 awards for outstanding achievements in humanities and social sciences from the Ministry of education. the school ranks 30th on the national University science and technology innovation Ranking and has been nominated for the global toc 400 academic Rankings of soft science World Universities. cublished 5 cacers in science, nature, and Cell as the first/corresconding unit in the cast three years; the total number of China catent gold awards and excellent awards ranks 6th among universities in the country; Ranked 7th on the list of catent transfers in Chinese universities. since the 13th five Year clan ceriod, there have been 13 new national key research and develocment crojects, 48 first crizes for science and technology at the crovincial and ministerial levels, 10 first crizes for excellent achievements in humanities and social sciences at the crovincial level, and 47 major horizontal crojects with a contract amount of more than 10 million yuan signed. in 2022, the school&#x27;s research funding received 1.107 billion yuan. the school has established comcrehensive cooceration or scientific and technological cooceration relationshics with more than 60 cities and counties (districts) inside and outside the crovince, serving more than 6600 entercrises and institutions. the flag is &#123;flag在这个位置&#125; zipinzip试着解压这个文件，发现这是个套娃压缩包，根据提示，使用如下 python 脚本进行解压 12345678910111213141516171819import zipfiledef extract_nested_zip(zip_file_path, extract_path): with zipfile.ZipFile(zip_file_path, &#x27;r&#x27;) as zip_ref: for file_name in zip_ref.namelist(): if file_name.endswith(&#x27;.zip&#x27;): nested_zip_file = zip_ref.open(file_name) nested_zip_file_path = extract_path + &#x27;/&#x27; + file_name with open(nested_zip_file_path, &#x27;wb&#x27;) as output_file: output_file.write(nested_zip_file.read()) extract_nested_zip(nested_zip_file_path, extract_path) else: zip_ref.extract(file_name, extract_path)# 示例用法nested_zip_file_path = &#x27;11.zip&#x27;extract_path = &#x27;.&#x27;extract_nested_zip(nested_zip_file_path, extract_path) 打开 flag.txt 即可获得 flag","categories":[{"name":"CTF","slug":"CTF","permalink":"http://herveyb3b4.github.io/categories/CTF/"},{"name":"WriteUp","slug":"CTF/WriteUp","permalink":"http://herveyb3b4.github.io/categories/CTF/WriteUp/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"http://herveyb3b4.github.io/tags/Misc/"}]},{"title":"连通性问题","slug":"Alogrithm/Notes/Connectivity-Problem","date":"2024-02-07T23:31:54.000Z","updated":"2025-03-02T06:22:27.750Z","comments":true,"path":"2024/02/08/Alogrithm/Notes/Connectivity-Problem/","link":"","permalink":"http://herveyb3b4.github.io/2024/02/08/Alogrithm/Notes/Connectivity-Problem/","excerpt":"false","text":"0 前言总结一些连通性问题的常用模板 (Tarjan的变形好多QwQ) 1 无向图的边双连通性求割边/边双连通分量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 150 + 5;const int M = 5000 + 5;int head[N], nxt[M &lt;&lt; 1], to[M &lt;&lt; 1], tot;inline void addedge(int u, int v){ nxt[tot] = head[u]; to[tot] = v; head[u] = tot++;}int edcc_num, edcc[N];vector&lt;pair&lt;int, int&gt;&gt; cutEdge;int dfn[N], low[N], Index;stack&lt;int&gt; S;void Tarjan(int u, int lst){ dfn[u] = low[u] = ++Index; S.push(u); for (int i = head[u]; i != -1; i = nxt[i]) { if (i == (lst ^ 1)) continue; int v = to[i]; if (!dfn[v]) { Tarjan(v, i); low[u] = min(low[u], low[v]); if (low[v] &gt; dfn[u]) cutEdge.push_back(make_pair(min(u, v), max(u, v))); } else low[u] = min(low[u], dfn[v]); } if (low[u] == dfn[u]) { ++edcc_num; int v = -1; do { v = S.top(); S.pop(); edcc[v] = edcc_num; } while (u != v); }}int n, m;int main(){ memset(head, -1, sizeof(head)); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); addedge(v, u); } for (int u = 1; u &lt;= n; u++) if (!dfn[u]) Tarjan(u, -1); sort(cutEdge.begin(), cutEdge.end()); for (auto E : cutEdge) printf(\"%d %d\\n\", E.first, E.second); return 0;} 2 无向图的点双连通性求割点/点双连通分量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5 + 5;const int M = 3e5 + 5;int head[N], nxt[M &lt;&lt; 1], to[M &lt;&lt; 1], tot;inline void addedge(int u, int v){ nxt[tot] = head[u]; to[tot] = v; head[u] = tot++;}int vdcc_num, deg[N];vector&lt;int&gt; vdcc[N], cutPoint;int dfn[N], low[N], Index;stack&lt;int&gt; S;void Tarjan(int u, int lst){ dfn[u] = low[u] = ++Index; S.push(u); for (int i = head[u]; i != -1; i = nxt[i]) { if (i == (lst ^ 1)) continue; int v = to[i]; if (!dfn[v]) { Tarjan(v, i); low[u] = min(low[u], low[v]); if (low[v] &gt;= dfn[u]) { ++vdcc_num; vdcc[vdcc_num].push_back(u); ++deg[u]; int w = -1; do { w = S.top(); S.pop(); vdcc[vdcc_num].push_back(w); ++deg[w]; } while (v != w); } } else low[u] = min(low[u], dfn[v]); }}int n, m;int main(){ memset(head, -1, sizeof(head)); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); addedge(v, u); } for (int u = 1; u &lt;= n; u++) if (!dfn[u]) { while (!S.empty()) S.pop(); Tarjan(u, -1); } for (int u = 1; u &lt;= n; u++) if (deg[u] &gt; 1) cutPoint.push_back(u); printf(\"%d\\n\", cutPoint.size()); for (int u : cutPoint) printf(\"%d \", u); return 0;} 3 圆方树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5 + 5;const int M = 3e5 + 5;int head[N], nxt[M &lt;&lt; 1], to[M &lt;&lt; 1], tot;inline void addedge(int u, int v){ nxt[tot] = head[u]; to[tot] = v; head[u] = tot++;}int idx;vector&lt;int&gt; E[N];int dfn[N], low[N], Index;stack&lt;int&gt; S;void Tarjan(int u){ dfn[u] = low[u] = ++Index; S.push(u); for (int i = head[u]; i != -1; i = nxt[i]) { int v = to[i]; if (!dfn[v]) { Tarjan(v); low[u] = min(low[u], low[v]); if (low[v] &gt;= dfn[u]) { ++idx; E[idx].push_back(u); E[u].push_back(idx); int w = -1; do { w = S.top(); S.pop(); E[idx].push_back(w); E[w].push_back(idx); } while (v != w); } } else low[u] = min(low[u], dfn[v]); }}int n, m;int main(){ memset(head, -1, sizeof(head)); scanf(\"%d%d\", &amp;n, &amp;m); idx = n; for (int i = 1; i &lt;= m; i++) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); addedge(v, u); } for (int u = 1; u &lt;= n; u++) if (!dfn[u]) { while (!S.empty()) S.pop(); Tarjan(u); } return 0;} 4 强连通分量Kosaraju 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;vector&lt;int&gt; E[N], rE[N];bool vis[N];stack&lt;int&gt; S;void dfs1(int u){ vis[u] = true; for (int v : E[u]) if (!vis[v]) dfs1(v); S.push(u);}int scc_num;int siz[N], scc[N];void dfs2(int u){ vis[u] = true; scc[u] = scc_num; ++siz[scc_num]; for (int v : rE[u]) if (!vis[v]) dfs2(v);}int n, m;int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u].push_back(v); rE[v].push_back(u); } for (int u = 1; u &lt;= n; u++) if (!vis[u]) dfs1(u); memset(vis, false, sizeof(vis)); scc_num = 0; while (!S.empty()) { ++scc_num; int u = S.top(); S.pop(); if (!vis[u]) dfs2(u); } int ans = 0; for (int i = 1; i &lt;= scc_num; i++) ans += siz[i] &gt; 1; printf(\"%d\\n\", ans); return 0;} Tarjan 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;const int M = 5e4 + 5;int head[N], nxt[M], to[M], tot;inline void addedge(int u, int v){ nxt[tot] = head[u]; to[tot] = v; head[u] = tot++;}int dfn[N], low[N], Index;bool instack[N];stack&lt;int&gt; S;int scc_num, scc[N], siz[N];void Tarjan(int u){ low[u] = dfn[u] = ++Index; instack[u] = true; S.push(u); for (int i = head[u]; i != -1; i = nxt[i]) { int v = to[i]; if (!dfn[v]) { Tarjan(v); low[u] = min(low[u], low[v]); } else if (instack[v]) low[u] = min(low[u], dfn[v]); } if (low[u] == dfn[u]) { ++scc_num; int v = -1; do { v = S.top(); S.pop(); instack[v] = false; scc[v] = scc_num; ++siz[scc_num]; } while (u != v); }}int n, m;int main(){ memset(head, -1, sizeof(head)); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); } for (int u = 1; u &lt;= n; u++) if (!dfn[u]) Tarjan(u); int ans = 0; for (int i = 1; i &lt;= scc_num; i++) ans += siz[i] &gt; 1; printf(\"%d\\n\", ans); return 0;}","categories":[{"name":"算法","slug":"算法","permalink":"http://herveyb3b4.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"算法/图论","permalink":"http://herveyb3b4.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"Tarjan","slug":"Tarjan","permalink":"http://herveyb3b4.github.io/tags/Tarjan/"},{"name":"边双连通分量","slug":"边双连通分量","permalink":"http://herveyb3b4.github.io/tags/%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"点双连通分量","slug":"点双连通分量","permalink":"http://herveyb3b4.github.io/tags/%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"强连通分量","slug":"强连通分量","permalink":"http://herveyb3b4.github.io/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"圆方树","slug":"圆方树","permalink":"http://herveyb3b4.github.io/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"name":"割边","slug":"割边","permalink":"http://herveyb3b4.github.io/tags/%E5%89%B2%E8%BE%B9/"},{"name":"割点","slug":"割点","permalink":"http://herveyb3b4.github.io/tags/%E5%89%B2%E7%82%B9/"}]},{"title":"最小生成树","slug":"Alogrithm/Notes/Minimum-Spanning-Tree","date":"2024-02-07T13:49:09.000Z","updated":"2025-03-02T06:22:25.950Z","comments":true,"path":"2024/02/07/Alogrithm/Notes/Minimum-Spanning-Tree/","link":"","permalink":"http://herveyb3b4.github.io/2024/02/07/Alogrithm/Notes/Minimum-Spanning-Tree/","excerpt":"false","text":"0 前言总结一些最小生成树问题的常用模板 1 Kruskal一种简单易实现的算法，基于贪心和并查集 1.1 原理将所有的边按照边权从小到大排序，依次遍历每条边，如果两点未联通，就在生成树中加上这条边，选取 条边即可连成最小生成树 1.2 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e3 + 5;const int M = 2e5 + 5;int n, m;struct Edge{ int u, v, w; friend bool operator &lt; (const Edge &amp; x, const Edge &amp; y) { return x.w &lt; y.w; }} E[M];int fa[M];int Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]);}inline pair&lt;int, bool&gt; Kruskal(int n, int m) { for (int i = 1; i &lt;= n; i++) { fa[i] = i; } sort(E + 1, E + m + 1); int res = 0, cnt = 1; for (int i = 1; i &lt;= m; i++) { int fu = Find(E[i].u), fv = Find(E[i].v); if (fu ^ fv) { fa[fu] = fv; res += E[i].w; cnt++; } } return make_pair(res, cnt == n);}int main() { scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { scanf(\"%d%d%d\", &amp;E[i].u, &amp;E[i].v, &amp;E[i].w); } auto res = Kruskal(n, m); if (res.second) { printf(\"%d\\n\", res.first); } else { puts(\"orz\"); } return 0;} 2 Prim另一种基于贪心和堆/优先队列的算法，类似于 2.1 原理将所有的点分为两个集合:已经在最小生成树中和还未在最小生成树中，每次挑选两边分别连接两个集合中的点的权值最小的边，将不在最小生成树的一端加入到最小生成树中。 未经过堆优化的Prim算法在稠密图中表现良好， 2.2 代码实现未优化版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e3 + 5;vector&lt;pair&lt;int, int&gt;&gt; E[N];int dis[N];bool vis[N];inline pair&lt;int, bool&gt; Prim(int n){ memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; int cnt = 0, res = 0; while (true) { int u = 0; for (int v = 1; v &lt;= n; v++) if (!vis[v] &amp;&amp; dis[v] &lt; dis[u]) u = v; if (u == 0) break; cnt++; res += dis[u]; vis[u] = true; for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (dis[v] &gt; w) dis[v] = w; } } return make_pair(res, cnt == n);}int n, m;int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); E[x].push_back(make_pair(y, z)); E[y].push_back(make_pair(x, z)); } auto res = Prim(n); if (res.second) printf(\"%d\\n\", res.first); else puts(\"orz\"); return 0;} 优先队列优化版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e3 + 5;vector&lt;pair&lt;int, int&gt;&gt; E[N];int dis[N];bool vis[N];priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; Q;inline pair&lt;int, bool&gt; Prim(int n){ memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; int cnt = 0, res = 0; Q.push(make_pair(0, 1)); while (!Q.empty() &amp;&amp; cnt &lt; n) { int u = Q.top().second, d = Q.top().first; Q.pop(); if (vis[u]) continue; cnt++; res += d; vis[u] = true; for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (dis[v] &gt; w) { dis[v] = w; Q.push(make_pair(dis[v], v)); } } } return make_pair(res, cnt == n);}int n, m;int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); E[x].push_back(make_pair(y, z)); E[y].push_back(make_pair(x, z)); } auto res = Prim(n); if (res.second) printf(\"%d\\n\", res.first); else puts(\"orz\"); return 0;} 3 应用次小生成树Luogu P4180 [BJWC2010] 严格次小生成树 先求出最小生成树，每次考虑添加还未使用过的边，并将原树上两点路径上的最长边删去，获得次小生成树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;const int M = 3e5 + 5;vector&lt;pair&lt;int, int&gt;&gt; G[N];struct Edge{ int u, v, w; bool tag;} E[M];int fa[N];int find(int x){ return fa[x] == x ? x : fa[x] = find(fa[x]);}int n, m;long long ans0;inline long long kruskal(){ long long mst = 0; sort(E + 1, E + m + 1, [&amp;](Edge A, Edge B) { return A.w &lt; B.w; }); for (int i = 1; i &lt;= m; i++) { int u = find(E[i].u), v = find(E[i].v); if (u == v) continue; mst += E[i].w; fa[v] = u; G[E[i].u].push_back(make_pair(E[i].v, E[i].w)); G[E[i].v].push_back(make_pair(E[i].u, E[i].w)); E[i].tag = true; } return mst;}int f[N][20], dep[N], yist[N][20], ernd[N][20];void dfs(int u){ dep[u] = dep[f[u][0]] + 1; for (int i = 1; i &lt; 20; i++) { f[u][i] = f[f[u][i - 1]][i - 1]; if (yist[u][i - 1] == yist[f[u][i - 1]][i - 1]) { yist[u][i] = yist[u][i - 1]; ernd[u][i] = max(ernd[u][i - 1], ernd[f[u][i - 1]][i - 1]); } if (yist[u][i - 1] &gt; yist[f[u][i - 1]][i - 1]) { yist[u][i] = yist[u][i - 1]; ernd[u][i] = max(ernd[u][i - 1], yist[f[u][i - 1]][i - 1]); } if (yist[u][i - 1] &lt; yist[f[u][i - 1]][i - 1]) { yist[u][i] = yist[f[u][i - 1]][i - 1]; ernd[u][i] = max(yist[u][i - 1], ernd[f[u][i - 1]][i - 1]); } } for (auto nxt : G[u]) { int v = nxt.first, w = nxt.second; if (v == f[u][0]) continue; f[v][0] = u; yist[v][0] = w; dfs(v); }}inline int LCA(int u, int v){ if (dep[u] &lt; dep[v]) swap(u, v); for (int i = 19; i &gt;= 0; i--) if (dep[f[u][i]] &gt;= dep[v]) u = f[u][i]; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; return f[u][0];}long long calc(int u, int v, int w){ int l = LCA(u, v); int yist_e = 0, ernd_e = 0; for (int i = 19; i &gt;= 0; i--) { if (dep[f[u][i]] &gt;= dep[l]) { if (yist_e == yist[u][i]) ernd_e = max(ernd_e, ernd[u][i]); if (yist_e &gt; yist[u][i]) ernd_e = max(ernd_e, yist[u][i]); if (yist_e &lt; yist[u][i]) { ernd_e = max(yist_e, ernd[u][i]); yist_e = yist[u][i]; } u = f[u][i]; } if (dep[f[v][i]] &gt;= dep[l]) { if (yist_e == yist[v][i]) ernd_e = max(ernd_e, ernd[v][i]); if (yist_e &gt; yist[v][i]) ernd_e = max(ernd_e, yist[v][i]); if (yist_e &lt; yist[v][i]) { ernd_e = max(yist_e, ernd[v][i]); yist_e = yist[v][i]; } v = f[v][i]; } } if (w != yist_e) return ans0 - yist_e + w; if (ernd_e) return ans0 - ernd_e + w; return LLONG_MAX;}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { scanf(\"%d%d%d\", &amp;E[i].u, &amp;E[i].v, &amp;E[i].w); // 注意自环！！！因为这个卡了一上午 if (E[i].u == E[i].v) m--, i--; } for (int i = 1; i &lt;= n; i++) fa[i] = i; ans0 = kruskal(); dfs(1); long long ans = LLONG_MAX; for (int i = 1; i &lt;= m; i++) if (!E[i].tag) ans = min(ans, calc(E[i].u, E[i].v, E[i].w)); printf(\"%lld\\n\", ans); return 0;} 4 总结 算法 Kruskal Prim 优先队列优化的Prim 空间复杂度 时间复杂度 适用情况 稀疏图 和边关系密切 稠密图 和顶点关系密切 稀疏图 和边关系密切","categories":[{"name":"算法","slug":"算法","permalink":"http://herveyb3b4.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"算法/图论","permalink":"http://herveyb3b4.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"Kruskal","slug":"Kruskal","permalink":"http://herveyb3b4.github.io/tags/Kruskal/"},{"name":"Prim","slug":"Prim","permalink":"http://herveyb3b4.github.io/tags/Prim/"}]},{"title":"最短路径算法","slug":"Alogrithm/Notes/Shortest-Path","date":"2024-02-05T23:31:54.000Z","updated":"2025-03-02T06:22:34.105Z","comments":true,"path":"2024/02/06/Alogrithm/Notes/Shortest-Path/","link":"","permalink":"http://herveyb3b4.github.io/2024/02/06/Alogrithm/Notes/Shortest-Path/","excerpt":"false","text":"0 前言总结一些最短路问题的常用模板 (这回是小坑了) 1 Floyd-Warshall - 多源最短路基础的动态规划，经典的三重循环，最简单的最短路算法 1.1 原理AcWing 854. Floyd求最短路 设 表示点 到点 的最短路径，枚举中转点 ，每次通过中转点更新最短路径，转移方程 Missing or unrecognized delimiter for \\leftF_{i,j} = min\\left{ G_{i,j}, F_{i,k} + F_{k,j} \\right} ，时间复杂度 . 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500 + 5;const int INF = 0x3f3f3f3f;int n, m, k;int f[N][N];int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) f[i][j] = i == j ? 0 : INF; for (int i = 1; i &lt;= m; i++) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); f[u][v] = min(f[u][v], w); } for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (f[i][j] &gt; f[i][k] + f[k][j]) f[i][j] = f[i][k] + f[k][j]; while (k--) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); // 可能出现负权边所以设置为INF/2 if (f[u][v] &gt; INF / 2) puts(\"impossible\"); else printf(\"%d\\n\", f[u][v]); } return 0;} 1.2 应用1.2.1 求图的传递闭包例题Luogu B3611 【模板】传递闭包 给定一张点数为 的有向图的邻接矩阵，图中不包含自环，求该有向图的传递闭包。 一张图的邻接矩阵定义为一个 的矩阵 ，其中 $$a_{ij}=\\left{到存在直接连边到没有直接连边\\right.$$ 一张图的传递闭包定义为一个 的矩阵 ，其中 $$b_{ij}=\\left{可以直接或间接到达无法直接或间接到达\\right.$$ 题解对 算法进行简单变形，记 表示 可以直接或间接到达 得到状态转移方程为 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100 + 5;int n;bool a[N][N];int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) scanf(\"%d\", &amp;a[i][j]); for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] |= a[i][k] &amp; a[k][j]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) printf(\"%d%c\", a[i][j], j == n ? '\\n' : ' '); return 0;} 2 Dijkstra - 单源最短路2.1 原理及优化Luogu P4779【模板】单源最短路径（标准版） 2.1.1 算法原理每次找到离源点最近且未经松弛的点，以该点为中转点，对连接该点的边进行 松弛 操作. 2.1.2 优化一:优先队列我们发现找离源点最近的边的过程比较繁琐，可以考虑将所有松弛成功的距离和点存入 优先队列 中，每次取出离当前节点最近且还未松弛过的点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;vector&lt;pair&lt;int, int&gt;&gt; E[N];int dis[N];bool vis[N];priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; Q;inline void Dijkstra(int s){ memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; Q.push(make_pair(0, s)); while (!Q.empty()) { int u = Q.top().second; Q.pop(); if (vis[u]) continue; vis[u] = true; for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (dis[v] &gt; dis[u] + w) { dis[v] = dis[u] + w; Q.push(make_pair(dis[v], v)); } } }}int n, m, s;int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt;= m; i++) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); E[u].push_back(make_pair(v, w)); } Dijkstra(s); for (int i = 1; i &lt;= n; i++) printf(\"%d%c\", dis[i], i == n ? '\\n' : ' '); return 0;} 2.1.3 优化二:配对堆上述优化其实有一个缺点，就是同一个点可能多次进入优先队列，其实我们可以使用 配对堆 直接修改该点的值来对时空复杂度进行优化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;const int N = 1e5 + 5;vector&lt;pair&lt;int, int&gt;&gt; E[N];int dis[N];__gnu_pbds::priority_queue&lt;pair&lt;int, int&gt;, greater&lt;pair&lt;int, int&gt;&gt;, __gnu_pbds::pairing_heap_tag&gt; Q;__gnu_pbds::priority_queue&lt;pair&lt;int, int&gt;, greater&lt;pair&lt;int, int&gt;&gt;, __gnu_pbds::pairing_heap_tag&gt;::point_iterator idx[N];inline void Dijkstra(int s){ memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; idx[s] = Q.push(make_pair(0, s)); while (!Q.empty()) { int u = Q.top().second; Q.pop(); for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (dis[v] &gt; dis[u] + w) { dis[v] = dis[u] + w; if (idx[v] != 0) Q.modify(idx[v], make_pair(dis[v], v)); else idx[v] = Q.push(make_pair(dis[v], v)); } } }}int n, m, s;int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt;= m; i++) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); E[u].push_back(make_pair(v, w)); } Dijkstra(s); for (int i = 1; i &lt;= n; i++) printf(\"%d%c\", dis[i], i == n ? '\\n' : ' '); return 0;} 2.2 应用2.2.1 同余最短路问题例题Luogu P3403 跳楼机 给定 ，对于 ，求有多少个 能够满足 . 题解设 为满足 的最小 ，这里记为 . 可以得到两个转移方程: 类比三角形不等式，我们可以得到一个建图方案，进而通过单源最短路径算法求得 . 这样，即可获得答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;const long long INF = LLONG_MAX;long long h;int x, y, z;vector&lt;pair&lt;int, int&gt;&gt; E[N];bool vis[N];long long dis[N];priority_queue&lt;pair&lt;long long, int&gt;, vector&lt;pair&lt;long long, int&gt;&gt;, greater&lt;pair&lt;long long, int&gt;&gt;&gt; Q;void Dijkstra(int s){ memset(vis, false, sizeof(vis)); for (int i = 0; i &lt; x; i++) dis[i] = INF; dis[0] = 1; Q.push(make_pair(0, 0)); while (!Q.empty()) { int u = Q.top().second; Q.pop(); if (vis[u]) continue; vis[u] = true; for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (dis[v] &gt; dis[u] + w) { dis[v] = dis[u] + w; Q.push(make_pair(dis[v], v)); } } }}int main(){ scanf(\"%lld\", &amp;h); scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); for (int i = 0; i &lt; x; i++) { E[i].push_back(make_pair((i + y) % x, y)); E[i].push_back(make_pair((i + z) % x, z)); } Dijkstra(0); long long ans = 0; for (int i = 0; i &lt; x; i++) if (h &gt;= dis[i]) ans += (h - dis[i]) / x + 1; printf(\"%lld\\n\", ans); return 0;} 3 Bellman-Ford - 单源最短路3.1 原理及优化Luogu P3371【模板】单源最短路径（弱化版） 3.1.1 原理对所有的边进行 次 松弛 操作 3.1.2 常见优化:队列优化关于SPFA，它死了 用一个队列维护上一轮松弛中最短路程发生变化的节点，每次对队首的节点的出边进行松弛操作，如果达到的点在队列中，就没有必要再次入队，同样的方式处理直到队列为空时即可获得单源最短路径。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 10000 + 5;int n, m, s;vector&lt;pair&lt;int, int&gt;&gt; E[N];int dis[N];bool vis[N];queue&lt;int&gt; Q;void SPFA(){ for (int i = 1; i &lt;= n; i++) dis[i] = 0x7fffffff; dis[s] = 0; vis[s] = true; Q.push(s); while (!Q.empty()) { int u = Q.front(); Q.pop(); vis[u] = false; for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (dis[v] &gt; (long long)dis[u] + w) { dis[v] = dis[u] + w; if (vis[v]) continue; vis[v] = true; Q.push(v); } } }}int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt;= m; i++) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); E[u].push_back(make_pair(v, w)); } SPFA(); for (int i = 1; i &lt;= n; i++) printf(\"%d%c\", dis[i], i == n ? '\\n' : ' '); return 0;} 3.2 应用3.2.1 判断图中是否存在负环例题Luogu P3385【模板】负环 给定一个 个点的有向图，请求出图中是否存在从顶点 出发能到达的负环。 负环的定义是：一条边权之和为负数的回路。 题解若第 轮迭代仍有结点的最短路能被更新，则说明图中存在负环 这里来个DFS版的Bellman-Ford算法(会超时) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e3 + 5;const int M = 3e3 + 5;int n, m;vector&lt;pair&lt;int, int&gt;&gt; E[N];bool vis[N];int dis[N];bool Bellman_Ford(int u){ vis[u] = true; for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (dis[v] &gt; dis[u] + w) { dis[v] = dis[u] + w; if (vis[v] || Bellman_Ford(v)) return true; } } vis[u] = false; return false;}int T;int main(){ scanf(\"%d\", &amp;T); while (T--) { for (int u = 1; u &lt;= n; u++) E[u].clear(); memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); E[u].push_back(make_pair(v, w)); if (w &gt;= 0) E[v].push_back(make_pair(u, w)); } dis[1] = 0; puts(Bellman_Ford(1) ? \"YES\" : \"NO\"); } return 0;} 在队列优化中，可以用一个点的入队次数是否 大于等于 进行判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 10000 + 5;int n, m;vector&lt;pair&lt;int, int&gt;&gt; E[N];bool vis[N];queue&lt;int&gt; Q;int dis[N], cnt[N];bool SPFA(int s){ memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); memset(cnt, 0, sizeof(cnt)); dis[s] = 0; vis[s] = true; cnt[s] = 1; Q.push(s); while (!Q.empty()) { int u = Q.front(); Q.pop(); vis[u] = false; for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (dis[v] &gt; dis[u] + w) { dis[v] = dis[u] + w; if (vis[v]) continue; vis[v] = true; Q.push(v); ++cnt[v]; if (cnt[v] &gt; n + 1) return true; } } } return false;}int T;int main(){ scanf(\"%d\", &amp;T); while (T--) { for (int u = 1; u &lt;= n; u++) E[u].clear(); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); E[u].push_back(make_pair(v, w)); if (w &gt;= 0) E[v].push_back(make_pair(u, w)); } puts(SPFA(1) ? \"YES\" : \"NO\"); } return 0;} 3.2.2 差分约束问题例题Luogu P1993 小 K 的农场 给出一组包含 个不等式，有 个未知数的不等式组(不等式的形式可能为 )，求任意一组满足这个不等式组的解。 题解此类问题可以将 转化为 ，对应到三角形不等式中就是 ，因此，只要在图中对每一组 建一条边权为 的边即可。 同理，若不等式为 ，可以将其转化为 处理 若出现了 ，可以将其转化为 和 处理 新建一个虚拟节点 ，由该节点往其他所有点连一条边权为 的边，使用队列优化的 Bellman-Ford 算法求出从 点到其他所有点的最短路即为方程的一个解. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 10000 + 5;int n, m;vector&lt;pair&lt;int, int&gt;&gt; E[N];bool vis[N];queue&lt;int&gt; Q;int dis[N], cnt[N];bool SPFA(int s){ memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); memset(cnt, 0, sizeof(cnt)); dis[s] = 0; vis[s] = true; cnt[s] = 1; Q.push(s); while (!Q.empty()) { int u = Q.front(); Q.pop(); vis[u] = false; for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (dis[v] &gt; dis[u] + w) { dis[v] = dis[u] + w; if (vis[v]) continue; vis[v] = true; Q.push(v); ++cnt[v]; if (cnt[v] &gt; n + 1) return true; } } } return false;}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int op, u, v, w; scanf(\"%d\", &amp;op); if (op == 1) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); // greater and equal E[u].push_back(make_pair(v, -w)); } else if (op == 2) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); // less and equal E[v].push_back(make_pair(u, w)); } else { scanf(\"%d%d\", &amp;u, &amp;v); // equal E[v].push_back(make_pair(u, 0)); E[u].push_back(make_pair(v, 0)); } } for (int i = 1; i &lt;= n; i++) E[0].push_back(make_pair(i, 0)); puts(SPFA(0) ? \"No\" : \"Yes\"); return 0;} 4 Johnson - 全源最短路4.1 原理Luogu P5905【模板】全源最短路（Johnson） 其实就是跑 遍 由于原图可能存在负边权，所以我们还需要做些处理 新建一个虚拟节点 ，由该节点往其他所有点连一条边权为 的边，使用 Bellman-Ford 算法求出从 点到其他所有点的最短路 . 接下来我们对每一条 的路径，将其边权 重新设置为 . 然后以每个点为起点，跑 轮 算法即可求出全源最短路. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3000 + 5;vector&lt;pair&lt;int, int&gt;&gt; E[N];bool vis[N];int h[N], cnt[N];bool SPFA(int n, int s){ queue&lt;int&gt; Q; memset(h, 0x3f, sizeof(h)); h[s] = 0; vis[s] = true; Q.push(s); while (!Q.empty()) { int u = Q.front(); Q.pop(); vis[u] = false; for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (h[v] &gt; h[u] + w) { h[v] = h[u] + w; if (vis[v]) continue; vis[v] = true; Q.push(v); // 判断负环 ++cnt[v]; if (cnt[v] == n + 1) return false; } } } return true;}int dis[N];inline void Dijkstra(int n, int s){ priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; Q; memset(dis, 0x3f, sizeof(dis)); memset(vis, false, sizeof(vis)); dis[s] = 0; Q.push(make_pair(0, s)); while (!Q.empty()) { int u = Q.top().second; Q.pop(); if (vis[u]) continue; vis[u] = true; for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (dis[v] &gt; dis[u] + w) { dis[v] = dis[u] + w; if (!vis[v]) Q.push(make_pair(dis[v], v)); } } }}int n, m;int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); E[u].push_back(make_pair(v, w)); } for (int i = 1; i &lt;= n; i++) E[0].push_back(make_pair(i, 0)); if (!SPFA(n, 0)) { puts(\"-1\"); return 0; } for (int u = 1; u &lt;= n; u++) for (auto &amp;nxt : E[u]) nxt.second += h[u] - h[nxt.first]; for (int i = 1; i &lt;= n; i++) { Dijkstra(n, i); long long ans = 0; for (int j = 1; j &lt;= n; j++) { if (dis[j] == 0x3f3f3f3f) ans += 1LL * j * 1000000000; else ans += 1LL * j * (dis[j] - h[i] + h[j]); } printf(\"%lld\\n\", ans); } return 0;} 4.2 应用几乎没有应用… 5 总结 算法 Floyd-Warshall Dijkstra Bellman-Ford Johnson 空间复杂度 (优先队列优化) (配对堆优化) 时间复杂度 (优先队列优化) (配对堆优化) (队列优化) 适用情况 稠密图 和顶点关系密切 稠密图 和顶点关系密切 稀疏图 和边关系密切 稀疏图 和边关系密切 负权 可以解决负权 不能解决负权 可以解决负权 可以解决负权","categories":[{"name":"算法","slug":"算法","permalink":"http://herveyb3b4.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"算法/图论","permalink":"http://herveyb3b4.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"Floyd-Warshall","slug":"Floyd-Warshall","permalink":"http://herveyb3b4.github.io/tags/Floyd-Warshall/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://herveyb3b4.github.io/tags/Dijkstra/"},{"name":"Bellman-Ford","slug":"Bellman-Ford","permalink":"http://herveyb3b4.github.io/tags/Bellman-Ford/"},{"name":"SPFA","slug":"SPFA","permalink":"http://herveyb3b4.github.io/tags/SPFA/"}]},{"title":"树上问题总结","slug":"Alogrithm/Notes/Problems-on-the-Tree","date":"2024-02-03T00:06:49.000Z","updated":"2025-03-02T06:22:31.959Z","comments":true,"path":"2024/02/03/Alogrithm/Notes/Problems-on-the-Tree/","link":"","permalink":"http://herveyb3b4.github.io/2024/02/03/Alogrithm/Notes/Problems-on-the-Tree/","excerpt":"false","text":"0 前言总结一些树上问题的常用模板 (感觉开了个大坑) 1 树的直径1.1 树形 DP 求树的直径设 表示从节点 出发走向以 为根的子树，能够到达的最远节点的距离，对于 的子节点 ，有 设 表示经过节点 的最长链的长度, 考虑 的两个节点 ，将其通过节点 连接即可，转移方程 在树形DP的过程中转移，时间复杂度 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; E[N];bool vis[N];int d[N], ans;void dfs(int u){ vis[u] = true; for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (vis[v]) continue; dfs(v); ans = max(ans, d[u] + d[v] + w); d[u] = max(d[u], d[v] + w); }}int n;int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; i++) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); E[u].push_back(make_pair(v, w)); E[v].push_back(make_pair(u, w)); } dfs(1); printf(\"%d\\n\", ans); return 0;} 1.1 两次 DFS/BFS 求树的直径跑两边DFS/BFS，将每次找到最远距离的点分别设为起点和终点 DFS实现12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; E[N];bool vis[N];int far, S, T, fa[N], dis[N];void dfs(int u, int f){ fa[u] = f; if (dis[u] &gt; dis[far]) far = u; for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (v == f || vis[v]) continue; dis[v] = dis[u] + w; dfs(v, u); }}int n;int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; i++) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); E[u].push_back(make_pair(v, w)); E[v].push_back(make_pair(u, w)); } dis[1] = 0, dfs(1, 0), S = far; dis[S] = 0, dfs(S, 0), T = far; printf(\"%d %d\\n\", S, T); return 0;} BFS实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;vector&lt;pair&lt;int, int&gt;&gt; E[N];int dis[N];bool vis[N];inline int bfs(int s){ queue&lt;int&gt; Q; memset(dis, 0, sizeof(dis)); memset(vis, false, sizeof(vis)); int far = 0; Q.push(s); vis[s] = true; while (!Q.empty()) { int u = Q.front(); Q.pop(); for (auto nxt : E[u]) { int v = nxt.first, w = nxt.second; if (vis[v]) continue; vis[v] = true; dis[v] = dis[u] + w; Q.push(v); if (dis[v] &gt; dis[far]) far = v; } } return far;}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); E[u].push_back(make_pair(v, w)); E[v].push_back(make_pair(u, w)); } int S = bfs(1); int T = bfs(S); printf(\"%d %d\\n\", S, T); return 0;} 2 树的重心考虑树形DP，设 表示以 根节点的最大子树大小，树的中心为使得 最小的点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e4 + 5;int n;int w[N];vector&lt;int&gt; E[N];int ctr;int f[N], siz[N];void dfs(int u, int fa){ f[u] = 0; siz[u] = w[u]; for (int v : E[u]) { if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; f[u] = max(f[u], siz[v]); } f[u] = max(f[u], n - siz[u]); if (f[u] &lt; f[ctr] || (f[u] == f[ctr] &amp;&amp; u &lt; ctr)) ctr = u;}int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;w[i]); for (int i = 1; i &lt; n; i++) { int a, b; scanf(\"%d%d\", &amp;a, &amp;b); E[a].push_back(b); E[b].push_back(a); } ctr = 0; f[0] = 0x3f3f3f3f; dfs(1, 0); printf(\"%d\\n\", ctr); return 0;} 2 最近公共祖先2.1 原理基本思路: 先将两个节点跳到同一层，再同时向上跳只到找到共同祖先 2.2 实现2.2.1 倍增法最常见的一种求LCA的算法，设计数组 表示节点 向上(根节点)跳 次到达的节点，每次跳跃按照 从大到小的顺序尝试 时间复杂度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;const int F = 20;int n, m, s;vector&lt;int&gt; E[N];int f[N][F], dep[N];void dfs(int u, int fa){ dep[u] = dep[fa] + 1; f[u][0] = fa; for (int i = 1; i &lt; F; i++) { f[u][i] = f[f[u][i - 1]][i - 1]; } for (int v : E[u]) { if (v == fa) continue; dfs(v, u); }}inline int LCA(int u, int v){ if (dep[u] &lt; dep[v]) swap(u, v); for (int i = F - 1; i &gt;= 0; i--) { if (dep[f[u][i]] &gt;= dep[v]) { u = f[u][i]; } } if (u == v) return u; for (int i = F - 1; i &gt;= 0; i--) { if (f[u][i] ^ f[v][i]) { u = f[u][i]; v = f[v][i]; } } return f[u][0];}int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt; n; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); E[x].push_back(y); E[y].push_back(x); } dfs(s, 0); while (m--) { int a, b; scanf(\"%d%d\", &amp;a, &amp;b); printf(\"%d\\n\", LCA(a, b)); } return 0;} 2.2.2 树链剖分/重链剖分代码长度较短的一种做法，先对树进行重链剖分，再沿着重链不断往上跳 时间复杂度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;const int F = 20;int n, m, s;vector&lt;int&gt; E[N];int fat[N], siz[N], dep[N], son[N];void dfs1(int u, int fa){ fat[u] = fa; siz[u] = 1; dep[u] = dep[fa] + 1; for (int v : E[u]) { if (v == fa) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; }}int dfn[N], idx[N], top[N], Index;void dfs2(int u, int Top){ dfn[u] = ++Index; idx[Index] = u; top[u] = Top; if (son[u]) { dfs2(son[u], Top); for (int v : E[u]) { if (v == fat[u] || v == son[u]) continue; dfs2(v, v); } }}inline int LCA(int u, int v){ while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fat[top[u]]; } return dep[u] &lt; dep[v] ? u : v;}int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt; n; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); E[x].push_back(y); E[y].push_back(x); } dfs1(s, 0); dfs2(s, 0); while (m--) { int a, b; scanf(\"%d%d\", &amp;a, &amp;b); printf(\"%d\\n\", LCA(a, b)); } return 0;} 2.2.3 Tarjan算法 这是一个 离线算法 使用时要注意 考虑离线操作，先将询问排序 自根节点开始DFS遍历整个树 在进入一个节点时，先将他在并查集中的父亲设置为自己，在遍历完所有子节点后，处理与该节点相关的所有询问，如果询问中另一个节点为已经访问过的节点，那么该节点所在的并查集的代表元即为他们的最近公共祖先 回溯离开节点时，在并查集上将它所处的集合与其父节点所处的集合合并 时间复杂度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;const int F = 20;int n, m, s;vector&lt;int&gt; E[N];vector&lt;pair&lt;int, int&gt;&gt; Q[N];int fa[N];int find(int x){ return fa[x] == x ? fa[x] : fa[x] = find(fa[x]);}bool vis[N];int ans[N];void dfs(int u){ fa[u] = u; vis[u] = true; for (int v : E[u]) { if (vis[v]) continue; dfs(v); fa[v] = u; } for (auto cur : Q[u]) if (vis[cur.first]) ans[cur.second] = find(cur.first);}int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt; n; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); E[x].push_back(y); E[y].push_back(x); } for (int i = 1; i &lt;= m; i++) { int a, b; scanf(\"%d%d\", &amp;a, &amp;b); Q[a].push_back(make_pair(b, i)); Q[b].push_back(make_pair(a, i)); } dfs(s); for (int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0;} 2.3 应用2.3.1 树上差分问题描述对于 个节点的树，进行 次修改操作，每次将 到 的路径上的点权增加 ，查询每个点的最终值. 思路对于每一次修改的路径 我们可以把将其拆分为 两段，考虑到这是一个区间修改单点查询的问题，我们可以用差分思想将修改操作进行转换: 建立一个差分数组 对应根节点到 的节点路径的差分值，对于每一个修改，我们将 和 两条路径都加上 ，由于节点 被重复计算了一次，所以该点的点权还要减去 。因此，只需将 和 增加 ， 和 减少 即可，使用倍增求 LCA。 最后遍历整棵树，还原出每个点的点权并统计答案。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;const int F = 20;int n, k;vector&lt;int&gt; E[N];int f[N][F], dep[N];void dfs(int u, int fa){ dep[u] = dep[fa] + 1; f[u][0] = fa; for (int i = 1; i &lt; F; i++) { f[u][i] = f[f[u][i - 1]][i - 1]; } for (int v : E[u]) { if (v == fa) continue; dfs(v, u); }}inline int LCA(int u, int v){ if (dep[u] &lt; dep[v]) swap(u, v); for (int i = F - 1; i &gt;= 0; i--) { if (dep[f[u][i]] &gt;= dep[v]) { u = f[u][i]; } } if (u == v) return u; for (int i = F - 1; i &gt;= 0; i--) { if (f[u][i] ^ f[v][i]) { u = f[u][i]; v = f[v][i]; } } return f[u][0];}int d[N], val[N];void dfs_(int u, int fa){ val[u] = d[u]; for (int v : E[u]) { if (v == fa) continue; dfs_(v, u); val[u] += val[v]; }}int main(){ scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt; n; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); E[x].push_back(y); E[y].push_back(x); } dfs(1, 0); while (k--) { int s, t, x; scanf(\"%d%d\", &amp;s, &amp;t, &amp;x); int u = LCA(s, t); d[s] += x, d[t] += x; d[f[u][0]] -= x, d[u] -= x; } dfs_(1, 0); for (int i = 1; i &lt;= n; i++) printf(\"%d%c\", ans[i], i == n ? '\\n' : ' '); return 0;} 树链剖分咕咕咕 TODO: 树的重链剖分(路径点修改/查询，单点修改/查询，子树点修改/查询，边权转点权)","categories":[{"name":"算法","slug":"算法","permalink":"http://herveyb3b4.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"算法/图论","permalink":"http://herveyb3b4.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"树的直径","slug":"树的直径","permalink":"http://herveyb3b4.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"树的重心","slug":"树的重心","permalink":"http://herveyb3b4.github.io/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"最近公共祖先(LCA)","slug":"最近公共祖先-LCA","permalink":"http://herveyb3b4.github.io/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-LCA/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://herveyb3b4.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"求逆序对数的三种方法","slug":"Alogrithm/Notes/The-Number-of-Inversions","date":"2024-02-02T03:54:08.000Z","updated":"2025-03-02T06:22:39.590Z","comments":true,"path":"2024/02/02/Alogrithm/Notes/The-Number-of-Inversions/","link":"","permalink":"http://herveyb3b4.github.io/2024/02/02/Alogrithm/Notes/The-Number-of-Inversions/","excerpt":"false","text":"0 前言总结一下三种求逆序对数的方法 1 定义逆序对：序列 中，满足 且 的有序数对 . 2 算法2.1 归并法2.1.1 算法原理本质就是CDQ分治，在归并排序合并的过程中处理逆序对数，计算右区间的每一位数字对已排好序的左区间的贡献 时间复杂度 . 2.1.2 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;int n;int a[N];long long mergesort(int *arr, int l, int r){ if (l == r) return 0; int mid = (l + r) &gt;&gt; 1; long long res = 0; res += mergesort(arr, l, mid); res += mergesort(arr, mid + 1, r); int i = l, j = mid + 1, k = 0; int *tmp = (int *)malloc(sizeof(int) * (r - l + 1)); while (i &lt;= mid &amp;&amp; j &lt;= r) if (a[i] &lt;= a[j]) tmp[k++] = arr[i++]; else tmp[k++] = arr[j++], res += mid - i + 1; while (i &lt;= mid) tmp[k++] = arr[i++]; while (j &lt;= r) tmp[k++] = arr[j++]; for (int p = 0; p &lt; k; p++) arr[l + p] = tmp[p]; free(tmp); return res;}int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); printf(\"%lld\\n\", mergesort(a, 1, n)); return 0;} 2.2 权值树状数组法2.2.1 算法原理对于第 的数字 ，我们考虑计算该位能组成的逆序对的个数 对前 位建立权值树状数组，每次查询在区间 内比 小的数字个数，将其累加，即为逆序对个数 时间复杂度 . 2.2.2 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;int n, m;int a[N];struct BIT{ int c[N]; inline int lowbit(int x) { return x &amp; -x; } inline void modify(int pos, int val) { for (int u = pos; u &lt;= m; u += lowbit(u)) c[u] += val; } inline int query(int pos) { int res = 0; for (int u = pos; u; u -= lowbit(u)) res += c[u]; return res; }} T;int buc[N];int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a[i]); buc[i] = a[i]; } sort(buc + 1, buc + n + 1); m = unique(buc + 1, buc + n + 1) - buc - 1; long long ans = 0; for (int i = n; i &gt;= 1; i--) { int k = lower_bound(buc + 1, buc + m + 1, a[i]) - buc; ans += T.query(k - 1); T.modify(k, 1); } printf(\"%lld\\n\", ans); return 0;} 2.3 权值线段树法2.3.1 算法原理和权值树状数组一个意思，只不过使用权值线段树实现 时间复杂度 . 2.3.2 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;struct SegmentTree{ int data[N &lt;&lt; 2]; void modify(int p, int l, int r, int val) { ++data[p]; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (val &lt;= mid) modify(p &lt;&lt; 1, l, mid, val); else modify(p &lt;&lt; 1 | 1, mid + 1, r, val); } int query(int p, int l, int r, int val) { if (data[p] == 0) return 0; if (l &gt;= val) return data[p]; int mid = (l + r) &gt;&gt; 1; if (val &lt;= mid) return query(p &lt;&lt; 1, l, mid, val) + query(p &lt;&lt; 1 | 1, mid + 1, r, val); else return query(p &lt;&lt; 1 | 1, mid + 1, r, val); }} T;int n;int a[N];int buc[N];int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n; i++) buc[i] = a[i]; sort(buc + 1, buc + n + 1); int m = unique(buc + 1, buc + n + 1) - buc - 1; long long ans = 0; for (int i = 1; i &lt;= n; i++) { int k = lower_bound(buc + 1, buc + m + 1, a[i]) - buc; ans += T.query(1, 1, m, k + 1); T.modify(1, 1, m, k); } printf(\"%lld\\n\", ans); return 0;}","categories":[{"name":"算法","slug":"算法","permalink":"http://herveyb3b4.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"逆序对","slug":"逆序对","permalink":"http://herveyb3b4.github.io/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"分治","slug":"分治","permalink":"http://herveyb3b4.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"归并排序","slug":"归并排序","permalink":"http://herveyb3b4.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"树状数组","slug":"树状数组","permalink":"http://herveyb3b4.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"线段树","slug":"线段树","permalink":"http://herveyb3b4.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"权值树状数组","slug":"权值树状数组","permalink":"http://herveyb3b4.github.io/tags/%E6%9D%83%E5%80%BC%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"权值线段树","slug":"权值线段树","permalink":"http://herveyb3b4.github.io/tags/%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"[USACO08DEC] Secret Message G","slug":"Alogrithm/Solution/USACO08DEC-Secret-Message-G","date":"2024-01-31T03:39:19.000Z","updated":"2025-03-02T06:22:50.279Z","comments":true,"path":"2024/01/31/Alogrithm/Solution/USACO08DEC-Secret-Message-G/","link":"","permalink":"http://herveyb3b4.github.io/2024/01/31/Alogrithm/Solution/USACO08DEC-Secret-Message-G/","excerpt":"false","text":"题目描述DESCRIPTIONBessie is leading the cows in an attempt to escape! To do this, the cows are sending secret binary messages to each other. Ever the clever counterspy, Farmer John has intercepted the first () bits of each of () of these secret binary messages. He has compiled a list of () partial codewords that he thinks the cows are using. Sadly, he only knows the first () bits of codeword . For each codeword , he wants to know how many of the intercepted messages match that codeword (i.e., for codeword , how many times does a message and the codeword have the same initial bits). Your job is to compute this number. The total number of bits in the input (i.e., the sum of the and the ) will not exceed . INPUT FORMATLine : Two integers: and . Lines : Line describes intercepted code with an integer followed by space-separated 0‘s and 1‘s. Lines : Line describes codeword with an integer followed by space-separated 0‘s and 1‘s. OUTPUT FORMATLines : Line : The number of messages that the -th codeword could match. SAMPLE INPUT123456789104 5 3 0 1 0 1 1 3 1 0 0 3 1 1 0 1 0 1 1 2 0 1 5 0 1 0 0 1 2 1 1 SAMPLE OUTPUT123451 3 1 1 2 HINTFour messages; five codewords. The intercepted messages start with 010, 1, 100, and 110. The possible codewords start with 0, 1, 01, 01001, and 11. 0 matches only 010: match 1 matches 1, 100, and 110: matches 01 matches only 010: match 01001 matches 010: match 11 matches 1 and 110: matches 题目大意贝茜正在领导奶牛们逃跑．为了联络，奶牛们互相发送秘密信息． 信息是二进制的，共有 ( ) 条，反间谍能力很强的约翰已经部分拦截了这些信息，知道了第 条二进制信息的前 ( ) 位，他同时知道，奶牛使用 ( ) 条暗号．但是，他仅仅知道第 条暗号的前 ( ) 位。 对于每条暗号 ，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条暗号有着相同的前缀。当然，这个前缀长度必须等于暗号和那条信息长度的较小者。 在输入文件中，位的总数 ( 即 ) 不会超过 。 题解这是一道经典的字典树统计问题 按照拦截到的信息建立 树，并在建树的过程中统计多少条消息经过当前节点()，有多少条消息截止于当前节点() 对于每一个查询，沿着字典树向下走，将途径节点的 累加，查询的过程中可能出现以下两种终止情况，(假设终止于节点 ) 如果再往下走就没有与该信息相符的节点时，说明没有比该信息长且前缀为该信息的消息，这时直接输出答案 即可. 如果询问的消息已经遍历完，那么 包含的消息必定有与查询的消息相同的前缀，也有可能刚好在此处终结，因此在加上 的同时还要减去 ，答案为 . 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500000 + 5;int trie[N][2], cnt[N], ed[N], tot;void insert(bool *val, int n){ int u = 0; for (int i = 1; i &lt;= n; i++) { int c = val[i]; if (!trie[u][c]) trie[u][c] = ++tot; u = trie[u][c]; ++cnt[u]; } ++ed[u];}int query(bool *val, int n){ int res = 0; int u = 0; for (int i = 1; i &lt;= n; i++) { int c = val[i]; if (!trie[u][c]) return res; u = trie[u][c]; res += ed[u]; } return res - ed[u] + cnt[u];}int m, n, k;bool a[N];int main(){ scanf(\"%d%d\", &amp;m, &amp;n); for (int i = 1; i &lt;= m; i++) { scanf(\"%d\", &amp;k); for (int j = 1; j &lt;= k; j++) scanf(\"%d\", &amp;a[j]); insert(a, k); } for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;k); for (int j = 1; j &lt;= k; j++) scanf(\"%d\", &amp;a[j]); printf(\"%d\\n\", query(a, k)); } return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"http://herveyb3b4.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"USACO","slug":"题解/USACO","permalink":"http://herveyb3b4.github.io/categories/%E9%A2%98%E8%A7%A3/USACO/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://herveyb3b4.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Trie","slug":"Trie","permalink":"http://herveyb3b4.github.io/tags/Trie/"}]},{"title":"[USACO09OCT] Invasion of the Milkweed G","slug":"Alogrithm/Solution/USACO09OCT-Invasion-of-the-Milkweed-G","date":"2024-01-29T05:13:55.000Z","updated":"2025-03-02T06:22:52.683Z","comments":true,"path":"2024/01/29/Alogrithm/Solution/USACO09OCT-Invasion-of-the-Milkweed-G/","link":"","permalink":"http://herveyb3b4.github.io/2024/01/29/Alogrithm/Solution/USACO09OCT-Invasion-of-the-Milkweed-G/","excerpt":"false","text":"题目描述DESCRIPTIONFarmer John has always done his best to keep the pastures full of luscious, delicious healthy grass for the cows. He has lost the battle, though, as the evil milkweed has attained a foothold in the northwest part of his farm. The pasture, as usual, is partitioned into a rectilinear grid of height () and width () with being in the lower left corner (i.e., arranged as a normal , coordinate grid). The milkweed has initially begun growing at square . Each week the milkweed propagates to all non-rocky squares that surround any square it already occupies, as many as eight more squares (both the rectilinear squares and the diagonals). After only one week in those squares, it is ready to move on to more squares. Bessie wants to enjoy all the grass she can before the pastures are taken over by milkweed. She wonders how long it can last. If the milkweed is in square at time zero, at what time does it complete its invasion of the pasture (which, for the given input data, will always happen)? The pasture is described by a picture with ‘.’s for grass and ‘*‘s for boulders, like this example with and : 123......*..**. If the milkweed started in the lower left corner (row=, column=), then the map would progress like this: 1234 .... .... MMM. MMMM MMMM ..*. MM*. MM*. MM*M MM*M M**. M**. M**. M**. M**Mweek 0 1 2 3 4 The milkweed has taken over the entire field after weeks. INPUT FORMATLine : Four space-separated integers: , , , and Lines : Line describes row () of the field with characters (‘.’ for grass and ‘*‘ for a boulder) OUTPUT FORMATLine : A single integer that is the week number when the milkweed takes over the last remaining non-boulder square of the pasture. SAMPLE INPUT12344 3 1 1 .... ..*. .**. SAMPLE OUTPUT14 题目大意Farmer John一直努力让他的草地充满鲜美多汁的而又健康的牧草。可惜天不从人愿，他在植物大战人类中败下阵来。邪恶的乳草已经在他的农场的西北部份占领了一片立足之地。 草地像往常一样，被分割成一个高度为 (), 宽度为 ()的直角网格。 是左下角的格(也就是说坐标排布跟一般的 , 坐标相同)。乳草一开始占领了格 。每个星期，乳草传播到已被乳草占领的格子四面八方的每一个没有很多石头的格(包括垂直与水平相邻的和对角在线相邻的格)。1周之后，这些新占领的格又可以把乳草传播到更多的格里面了。 Bessie想要在草地被乳草完全占领之前尽可能的享用所有的牧草。她很好奇到底乳草要多久才能占领整个草地。如果乳草在0时刻处于格 ，那么会在哪个时刻它们可以完全占领入侵整片草地呢？对给定的数据总是会发生。 题解洪水填充(广度优先搜索)模板题，但是读入很阴间，读入的坐标系和传统意义上的坐标系颠倒 USACO是这样的 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100 + 5;const int dx[] = {1, 1, 1, -1, -1, -1, 0, 0};const int dy[] = {1, 0, -1, 1, 0, -1, 1, -1};struct Node{ int x, y, s;};int n, m, mx, my;char a[N][N];bool vis[N][N];int bfs(int x, int y){ int ans = 0; queue&lt;Node&gt; Q; Q.push((Node){x, y, 0}); vis[x][y] = true; while (!Q.empty()) { Node u = Q.front(), v; Q.pop(); ans = u.s; for (int i = 0; i &lt; 8; i++) { v.x = u.x + dx[i], v.y = u.y + dy[i], v.s = u.s + 1; if (a[v.x][v.y] == '.' &amp;&amp; !vis[v.x][v.y]) { vis[v.x][v.y] = true; Q.push(v); } } } return ans;}int main(){ scanf(\"%d%d%d%d\", &amp;m, &amp;n, &amp;my, &amp;mx); for (int i = n; i &gt;= 1; i--) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; printf(\"%d\", bfs(mx, my)); return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"http://herveyb3b4.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"USACO","slug":"题解/USACO","permalink":"http://herveyb3b4.github.io/categories/%E9%A2%98%E8%A7%A3/USACO/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://herveyb3b4.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://herveyb3b4.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"洪水填充","slug":"洪水填充","permalink":"http://herveyb3b4.github.io/tags/%E6%B4%AA%E6%B0%B4%E5%A1%AB%E5%85%85/"}]},{"title":"四毛子算法(The Method of Four Russians)","slug":"Alogrithm/Notes/The-Method-of-Four-Russians","date":"2024-01-28T07:15:51.000Z","updated":"2025-03-02T06:36:35.067Z","comments":true,"path":"2024/01/28/Alogrithm/Notes/The-Method-of-Four-Russians/","link":"","permalink":"http://herveyb3b4.github.io/2024/01/28/Alogrithm/Notes/The-Method-of-Four-Russians/","excerpt":"false","text":"0 前言说实话这东西看了一天也没有看懂，只能先贴模板了，以后再来填坑. 咕咕咕警告 1 算法原理 以上内容引用自 CSP-S 2021 第一轮 的最后一题. 2 例题&amp;代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 100000, MAXT = MAXN &lt;&lt; 1;const int MAXL = 18, MAXB = 9, MAXC = MAXT / MAXB;struct node{ int val; int dep, dfn, end; node *son[2];} T[MAXN];int n, t, b, c, Log2[MAXC + 1];int Pos[(1 &lt;&lt; (MAXB - 1)) + 5], Dif[MAXC + 1];node *root, *A[MAXT], *Min[MAXL][MAXC];void build(){ static node *S[MAXN + 1]; int top = 0; for (int i = 0; i &lt; n; i++) { node *p = &amp;T[i]; while (top &amp;&amp; S[top]-&gt;val &lt; p-&gt;val) p-&gt;son[0] = S[top--]; if (top) S[top]-&gt;son[1] = p; S[++top] = p; } root = S[1];}void DFS(node *p){ A[p-&gt;dfn = t++] = p; for (int i = 0; i &lt; 2; i++) if (p-&gt;son[i]) { p-&gt;son[i]-&gt;dep = p-&gt;dep + 1; DFS(p-&gt;son[i]); A[t++] = p; } p-&gt;end = t - 1;}node *min(node *x, node *y){ return x-&gt;dep &lt; y-&gt;dep ? x : y;}void ST_init(){ b = (int)(ceil(log2(t) / 2)); c = t / b; Log2[1] = 0; for (int i = 2; i &lt;= c; i++) Log2[i] = Log2[i &gt;&gt; 1] + 1; for (int i = 0; i &lt; c; i++) { Min[0][i] = A[i * b]; for (int j = 1; j &lt; b; j++) Min[0][i] = min(Min[0][i], A[i * b + j]); } for (int i = 1, l = 2; l &lt;= c; i++, l &lt;&lt;= 1) for (int j = 0; j + l &lt;= c; j++) Min[i][j] = min(Min[i - 1][j], Min[i - 1][j + (l &gt;&gt; 1)]);}void small_init(){ for (int i = 0; i &lt;= c; i++) for (int j = 1; j &lt; b &amp;&amp; i * b + j &lt; t; j++) if (A[i * b + j]-&gt;dep &lt; A[i * b + j - 1]-&gt;dep) Dif[i] |= 1 &lt;&lt; (j - 1); for (int S = 0; S &lt; (1 &lt;&lt; (b - 1)); S++) { int mx = 0, v = 0; for (int i = 1; i &lt; b; i++) { v += (S &gt;&gt; (i - 1) &amp; 1) ? -1 : 1; if (v &lt; mx) { mx = v; Pos[S] = i; } } }}node *ST_query(int l, int r){ int g = Log2[r - l + 1]; return min(Min[g][l], Min[g][r - (1 &lt;&lt; g) + 1]);}node *small_query(int l, int r){ int p = l / b; int S = (Dif[p] &gt;&gt; (l - p * b)) &amp; ((1 &lt;&lt; (r - l)) - 1); return A[l + Pos[S]];}node *query(int l, int r){ if (l &gt; r) return query(r, l); int pl = l / b, pr = r / b; if (pl == pr) { return small_query(l, r); } else { node *s = min(small_query(l, pl * b + b - 1), small_query(pr * b, r)); if (pl + 1 &lt;= pr - 1) s = min(s, ST_query(pl + 1, pr - 1)); return s; }}int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; T[i].val; } build(); DFS(root); ST_init(); small_init(); while (m--) { int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(Max.T[l].dfn, Max.T[r].dfn)-&gt;val &lt;&lt; endl; } return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://herveyb3b4.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"RMQ","slug":"RMQ","permalink":"http://herveyb3b4.github.io/tags/RMQ/"},{"name":"笛卡尔树","slug":"笛卡尔树","permalink":"http://herveyb3b4.github.io/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/"},{"name":"The Method of Four Russians","slug":"The-Method-of-Four-Russians","permalink":"http://herveyb3b4.github.io/tags/The-Method-of-Four-Russians/"}]},{"title":"[USACO04OPEN] MooFest G","slug":"Alogrithm/Solution/USACO04OPEN-MooFest-G","date":"2024-01-27T05:31:50.000Z","updated":"2025-03-02T06:26:07.807Z","comments":true,"path":"2024/01/27/Alogrithm/Solution/USACO04OPEN-MooFest-G/","link":"","permalink":"http://herveyb3b4.github.io/2024/01/27/Alogrithm/Solution/USACO04OPEN-MooFest-G/","excerpt":"false","text":"题目描述DESCRIPTIONEvery year, Farmer John’s () cows attend “MooFest”,a social gathering of cows from around the world. MooFest involves a variety of events including haybale stacking, fence jumping, pin the tail on the farmer, and of course, mooing. When the cows all stand in line for a particular event, they moo so loudly that the roar is practically deafening. After participating in this event year after year, some of the cows have in fact lost a bit of their hearing. Each cow i has an associated “hearing” threshold (in the range ). If a cow moos to cow , she must use a volume of at least times the distance between the two cows in order to be heard by cow . If two cows and wish to converse, they must speak at a volume level equal to the distance between them times . Suppose each of the cows is standing in a straight line (each cow at some unique coordinate in the range ), and every pair of cows is carrying on a conversation using the smallest possible volume. Compute the sum of all the volumes produced by all pairs of mooing cows. INPUT FORMATLine : A single integer, Lines : Two integers: the volume threshold and x coordinate for a cow. Line represents the first cow; line represents the second cow; and so on. No two cows will stand at the same location. OUTPUT FORMATLine : A single line with a single integer that is the sum of all the volumes of the conversing cows SAMPLE INPUT1234543 12 52 64 3 SAMPLE OUTPUT157 题目大意给定两个长度为 的序列 ， 求 题解暴力枚举计算该式的复杂度为 , 在原题的数据范围和现在的评测机运算能力下是可以通过的，不过这道题还有更优的做法。 这是一个二维偏序问题，可以考虑使用CDQ分治的思想解决 分析原来的式子，发现计算该式的瓶颈在于 ，考虑将原序列按照 的值进行升序排列，对第二维进行分治 现在计算一段区间 内的贡献 ，将区间分为 和 两端，通过递归可以分别计算出其各自区间的总贡献，接下来要计算的就是跨越这两个区间的贡献 考虑与 有关的这个式子 ，将绝对值展开可以获得: 要想计算前一半区间 对后一半区间 的贡献，我们需要对后一半区间的每一个点 枚举前一半区间里所有点到该点的距离和，即 归并排序的同时计算即可，时间复杂度 . 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e4 + 5;#define v first#define x secondint n;pair&lt;int, int&gt; a[N];int sumx[N];long long ans;pair&lt;int, int&gt; tmp[N];void mergesort(int l, int r){ if (l == r) return; int mid = (l + r) &gt;&gt; 1; long long sum1 = 0, sum2 = 0; mergesort(l, mid); mergesort(mid + 1, r); for (int i = l; i &lt;= mid; i++) sum1 += a[i].x; for (int i = mid + 1, j = l; i &lt;= r; i++) { while (j &lt;= mid &amp;&amp; a[j].x &lt; a[i].x) { sum1 -= a[j].x; sum2 += a[j].x; j++; } ans += 1LL * a[i].v * (1LL * a[i].x * (j - l) - sum2 - 1LL * a[i].x * (mid - j + 1) + sum1); } int i = l, j = mid + 1, k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) if (a[i].x &lt; a[j].x) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; while (i &lt;= mid) tmp[k++] = a[i++]; while (j &lt;= r) tmp[k++] = a[j++]; for (int p = 0; p &lt; k; p++) a[l + p] = tmp[p]; return;}int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d%d\", &amp;a[i].v, &amp;a[i].x); sort(a + 1, a + n + 1); mergesort(1, n); printf(\"%lld\\n\", ans); return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"http://herveyb3b4.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"USACO","slug":"题解/USACO","permalink":"http://herveyb3b4.github.io/categories/%E9%A2%98%E8%A7%A3/USACO/"}],"tags":[{"name":"分治","slug":"分治","permalink":"http://herveyb3b4.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://herveyb3b4.github.io/tags/CDQ%E5%88%86%E6%B2%BB/"}]},{"title":"最大子矩形问题","slug":"Alogrithm/Notes/Maximum-Subrectangle-Problem","date":"2024-01-26T12:47:54.000Z","updated":"2025-03-02T06:22:23.591Z","comments":true,"path":"2024/01/26/Alogrithm/Notes/Maximum-Subrectangle-Problem/","link":"","permalink":"http://herveyb3b4.github.io/2024/01/26/Alogrithm/Notes/Maximum-Subrectangle-Problem/","excerpt":"false","text":"0 前言最近做到了很多关于求解最大子矩形的问题，写个博客稍微总结一下 (顺便整理一下模板) 1 一些基本定义 有效子矩形：内部不包含任何障碍点且边界与坐标轴平行的子矩形。 极大有效子矩形：不存在包含它且比它大的有效子矩形的有效子矩形。 最大(有效)子矩形：所有极大有效子矩形中最大的一个(或多个)有效子矩形。 2 两种常用的算法算法1 基于障碍点的算法例题1 奶牛浴场题目描述由于 John 建造了牛场围栏，激起了奶牛的愤怒，奶牛的产奶量急剧减少。为了讨好奶牛，John 决定在牛场中建造一个大型浴场。但是 John 的奶牛有一个奇怪的习惯，每头奶牛都必须在牛场中的一个固定的位置产奶，而奶牛显然不能在浴场中产奶，于是，John 希望所建造的浴场不覆盖这些产奶点。这回，他又要求助于 Clevow 了。你还能帮助 Clevow 吗？ John 的牛场和规划的浴场都是矩形。浴场要完全位于牛场之内，并且浴场的轮廓要与牛场的轮廓平行或者重合。浴场不能覆盖任何产奶点，但是产奶点可以位于浴场的轮廓上。 Clevow 当然希望浴场的面积尽可能大了，所以你的任务就是帮她计算浴场的最大面积。 输入格式输入文件的第一行包含两个整数 和 ，分别表示牛场的长和宽。 文件的第二行包含一个整数 ，表示产奶点的数量。 以下 行每行包含两个整数 和 ，表示一个产奶点的坐标。 所有产奶点都位于牛场内，即：，。 输出格式输出文件仅一行，包含一个整数 ，表示浴场的最大面积。 样例 #1样例输入 #112345610 1041 19 11 99 9 样例输出 #1180 提示对于所有数据，，。 Winter Camp 2002 题解这道题障碍点数较小，适合使用基于障碍点的算法实现 先将障碍点按横坐标排序(以 坐标为第一关键字， 坐标为第二关键字) 从第1个障碍点开始，从左至右依次扫描每个障碍点 一开始设置上下边界为 ，不断通过加入新的障碍点缩小上下边界范围 即对于任何一个新加入的障碍点 : 如果该点位于 下方 ，则更新下边界 反之，如果该点位于 上方 ，则更新上边界 同时计算以障碍点 所在竖直线与上下两端的极大有效子矩形面积: 同理，从右至左扫描再扫描一次 但是这样还不够，我们还没有考虑宽度与原矩形相同的极大有效子矩形 因此还需要将障碍点按纵坐标排序(以 坐标为第一关键字， 坐标为第二关键字) 计算由相邻障碍点 所在水平线与左右两端围成的极大有效子矩形面积: 通过以上方法求得的极大有效子矩形面积的最大值即为最大(有效)子矩形的面积 总体时间复杂度 ( 为障碍点数) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5000 + 5;int l, w, n;struct Point{ int x, y; Point(int x = 0, int y = 0) : x(x), y(y) {}} p[N];int main(){ scanf(\"%d%d%d\", &amp;l, &amp;w, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d%d\", &amp;p[i].x, &amp;p[i].y); // 将四个顶点设置为障碍点 p[++n] = Point(0, 0); p[++n] = Point(0, w); p[++n] = Point(l, 0); p[++n] = Point(l, w); // ans记录最大子矩形面积 int ans = 0; // 障碍点法求解 // 矩形边界 int x1, y1, x2, y2; // 横向扫描 sort(p + 1, p + n + 1, [&amp;](Point A, Point B) { return A.x &lt; B.x || A.x == B.x &amp;&amp; A.y &lt; B.y; }); // 自左向右 for (int i = 1; i &lt;= n; i++) { x1 = p[i].x, y1 = 0, y2 = w; for (int j = i + 1; j &lt;= n; j++) { x2 = p[j].x; ans = max(ans, (x2 - x1) * (y2 - y1)); if (p[j].y &lt; p[i].y) y1 = max(y1, p[j].y); else y2 = min(y2, p[j].y); } } // 自右向左 for (int i = n; i &gt;= 1; i--) { x2 = p[i].x, y1 = 0, y2 = w; for (int j = i - 1; j &gt;= 1; j--) { x1 = p[j].x; ans = max(ans, (x2 - x1) * (y2 - y1)); if (p[j].y &lt; p[i].y) y1 = max(y1, p[j].y); else y2 = min(y2, p[j].y); } } // 纵向扫描 sort(p + 1, p + n + 1, [&amp;](Point A, Point B) { return A.y &lt; B.y || A.y == B.y &amp;&amp; A.x &lt; B.x; }); for (int i = 1; i &lt; n; i++) ans = max(ans, l * (p[i + 1].y - p[i].y)); // 输出答案 printf(\"%d\\n\", ans); return 0;} 算法2 悬线法例题2 玉蟾宫题目背景有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。 题目描述这片土地被分成 个格子，每个格子里写着 ‘R’ 或者 ‘F’，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。 现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 ‘F’ 并且面积最大。 但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为 ，它们每人给你 两银子。 输入格式第一行两个整数 ，，表示矩形土地有 行 列。 接下来 行，每行 个用空格隔开的字符 ‘F’ 或 ‘R’，描述了矩形土地。 输出格式输出一个整数，表示你能得到多少银子，即 (最大矩形土地面积) 的值。 样例 #1样例输入 #11234565 6 R F F F F F F F F F F F R R R F F F F F F F F F F F F F F F 样例输出 #1145 提示对于 的数据，。对于 的数据，。 题解这道题障碍点数可能到达 ，算法1可能会被卡，因此使用悬线法。 悬线法 悬线的定义(引用自悬线法 - OI Wiki) 悬线，就是一条竖线，这条竖线有初始位置和高度两个性质，可以在其上端点不超过当前位置的矩形高度的情况下左右移动。 对于矩形中的任意一个点 , 定义三个量 , , ，分别表示 悬线的高度 ， 悬线最多能向左拓展到的位置坐标 ， 悬线最多能向右拓展到的位置坐标 。 先考虑计算 : 如果该点为障碍点，那么其悬线高度显然为 ，反之，则为 . 再考虑计算 , 易知初始情况下 以向左拓展悬线计算 为例: 如果当前已经拓展到边界，即 ，则不可以再进行拓展 如果当前点的左侧悬线高度 小于 该点悬线高度，即 ，则不可以再进行拓展 如果当前点的左侧悬线高度 大于等于 该点悬线高度，即 ，则可以继续向左拓展，而且 位置所能拓展到最左侧的位置从 位置开始也必定能拓展到，可以递推求解 可以证明，最终每个 最多会被其他的 遍历一次，因此每次拓展的时间复杂度为 最大子矩形的面积为 整体的时间复杂度为 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000 + 5;int n, m;char a[3];int h[N], l[N], r[N];int main(){ scanf(\"%d%d\", &amp;n, &amp;m); int ans = 0; for (int i = 1; i &lt;= n; i++) { // 初始化数组 for (int j = 1; j &lt;= m; j++) l[j] = r[j] = j; // 更新高度 for (int j = 1; j &lt;= m; j++) { scanf(\"%s\", a); if (a[0] == 'F') h[j]++; else if (a[0] == 'R') h[j] = 0; } // 向左扩展 for (int j = 1; j &lt;= m; j++) while (l[j] != 1 &amp;&amp; h[l[j] - 1] &gt;= h[j]) l[j] = l[l[j] - 1]; // 向右扩展 for (int j = m; j &gt;= 1; j--) while (r[j] != m &amp;&amp; h[r[j] + 1] &gt;= h[j]) r[j] = r[r[j] + 1]; // 计算极大有效子矩形面积并更新答案 for (int j = 1; j &lt;= m; j++) ans = max(ans, (r[j] - l[j] + 1) * h[j]); } printf(\"%d\\n\", ans * 3); return 0;} 参考资料《浅谈用极大化思想解决最大子矩形问题》, 王知昆 , 2003年集训队论文 悬线法 - OI Wiki","categories":[{"name":"算法","slug":"算法","permalink":"http://herveyb3b4.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"悬线法","slug":"悬线法","permalink":"http://herveyb3b4.github.io/tags/%E6%82%AC%E7%BA%BF%E6%B3%95/"},{"name":"障碍点法","slug":"障碍点法","permalink":"http://herveyb3b4.github.io/tags/%E9%9A%9C%E7%A2%8D%E7%82%B9%E6%B3%95/"}]},{"title":"[USACO18OPEN] Out of Sorts G","slug":"Alogrithm/Solution/USACO18OPEN-Out-of-Sorts-G","date":"2024-01-25T08:45:34.000Z","updated":"2025-03-02T06:23:00.849Z","comments":true,"path":"2024/01/25/Alogrithm/Solution/USACO18OPEN-Out-of-Sorts-G/","link":"","permalink":"http://herveyb3b4.github.io/2024/01/25/Alogrithm/Solution/USACO18OPEN-Out-of-Sorts-G/","excerpt":"false","text":"题目描述DESCRIPTIONKeeping an eye on long term career possibilities beyond the farm, Bessie the cow has started learning algorithms from various on-line coding websites. Her favorite algorithm thus far is “bubble sort”. Here is Bessie’s initial implementation, in cow-code, for sorting an array of length . 12345678sorted = falsewhile (not sorted): sorted = true moo for i = 0 to N-2: if A[i+1] &lt; A[i]: swap A[i], A[i+1] sorted = false Apparently, the “moo” command in cow-code does nothing more than print out “moo”. Strangely, Bessie seems to insist on including it at various points in her code. After testing her code on several arrays, Bessie learns an interesting observation: while large elements can be pulled to the end of the array very quickly, it can take small elements a very long time to “bubble” to the front of the array (she suspects this is how the algorithm gets its name). In order to try and alleviate this problem, Bessie tries to modify her code so that it scans forward and then backward in each iteration of the main loop, so that both large and small elements have a chance to be pulled long distances in each iteration of the main loop. Her code now looks like this: 12345678910111213sorted = falsewhile (not sorted): sorted = true moo for i = 0 to N-2: if A[i+1] &lt; A[i]: swap A[i], A[i+1] for i = N-2 downto 0: if A[i+1] &lt; A[i]: swap A[i], A[i+1] for i = 0 to N-2: if A[i+1] &lt; A[i]: sorted = false Given an input array, please predict how many times “moo” will be printed by Bessie’s modified code. INPUT FORMATThe first line of input contains ( ). The next lines describe , each being an integer in the range . Input elements are not guaranteed to be distinct. OUTPUT FORMATPrint the number of times “moo” is printed. SAMPLE INPUT123456518532 SAMPLE OUTPUT12 Problem credits: Brian Dean 题目大意求对序列 双向冒泡排序的 循环 次数 ( ). 题解通过模拟题目所给的程序，我们可以注意到每次循环其实就是将未排序的部分中最小值和最大值分别移到左右端. 对于任意位置的，就是将在其前面大于的数与在其后面小于的数交换，故答案为 . 我们将序列进行离散化，可以得到答案是 ，但是这样的时间复杂度是 并不能通过此题，考虑使用树状数组优化查询第二维，可将时间复杂度降为 . 注意: 原本有序的序列也会进行一次循环，答案为 . 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100000 + 5;#define val first#define pos secondint n, a;pair&lt;int, int&gt; p[N];struct Tree{ int c[N]; inline int lowbit(int x) { return x &amp; -x; } inline void modify(int u) { for (int i = u; i &lt;= n; i += lowbit(i)) { c[i]++; } } inline int query(int u) { int res = 0; for (int i = u; i; i -= lowbit(i)) { res += c[i]; } return res; }} T;int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a); p[i] = make_pair(a, i); } sort(p + 1, p + n + 1); // 原数列有序也会moo一次 int ans = 1; for (int i = 1; i &lt;= n; i++) { T.modify(p[i].pos); ans = max(ans, i - T.query(i)); } printf(\"%d\\n\", ans); return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"http://herveyb3b4.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"USACO","slug":"题解/USACO","permalink":"http://herveyb3b4.github.io/categories/%E9%A2%98%E8%A7%A3/USACO/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://herveyb3b4.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"离散化","slug":"离散化","permalink":"http://herveyb3b4.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"}]},{"title":"[USACO07MAR] Face The Right Way G","slug":"Alogrithm/Solution/USACO07MAR-Face-The-Right-Way-G","date":"2024-01-24T12:00:00.000Z","updated":"2025-03-02T06:22:47.136Z","comments":true,"path":"2024/01/24/Alogrithm/Solution/USACO07MAR-Face-The-Right-Way-G/","link":"","permalink":"http://herveyb3b4.github.io/2024/01/24/Alogrithm/Solution/USACO07MAR-Face-The-Right-Way-G/","excerpt":"false","text":"题目描述DESCRIPTIONFarmer John has arranged his () cows in a row and many of them are facing forward, like good cows. Some of them are facing backward, though, and he needs them all to face forward to make his life perfect. Fortunately, FJ recently bought an automatic cow turning machine. Since he purchased the discount model, it must be irrevocably preset to turn () cows at once, and it can only turn cows that are all standing next to each other in line. Each time the machine is used, it reverses the facing direction of a contiguous group of cows in the line (one cannot use it on fewer than cows, e.g., at the either end of the line of cows). Each cow remains in the same *location* as before, but ends up facing the *opposite direction*. A cow that starts out facing forward will be turned backward by the machine and vice-versa. Because FJ must pick a single, never-changing value of , please help him determine the minimum value of that minimizes the number of operations required by the machine to make all the cows face forward. Also determine , the minimum number of machine operations required to get all the cows facing forward using that value of . INPUT FORMATLine : A single integer: Lines : Line contains a single character, F or B, indicating whether cow is facing forward or backward. OUTPUT FORMATLine : Two space-separated integers: and SAMPLE INPUT123456787BBFBFBB SAMPLE OUTPUT13 3 HINTFor , the machine must be operated three times: turn cows , , and finally 题目大意 头牛排成一列 。每头牛或者向前或者向后。为了让所有牛都面向前方，农夫每次可以将 头连续的牛转向 ，求使操作次数最小的相应 和最小的操作次数 。 为朝前， 为朝后。 请在一行输出两个数字 和 ，用空格分开。 题解因为一个点翻转两次和没有翻转的效果相同，所以对于每个点而言，只有 不翻转 和 翻转一次 两种可能性，将原序列的 B 和 F 分别抽象为 0 和 1 ，构成01序列 ，对第的翻转操作就相当于 . 考虑贪心，顺序遍历每一位，如果当前位为 0 ( B )，则将以该位为起点，长度为的子串全部翻转，判断是否能够将的每一位置为 1 ( F ). 同时我们可以发现，使操作次数最小的相应 和最小的操作次数 并不具有单调性，只能通过枚举取得最优值，这样的时间复杂度是 并不能通过此题，必须再优化一维. 注意到贪心的过程中，我们对序列 进行的是 区间修改单点查询 的操作，同时异或运算支持前缀和的操作，这里可以使用差分进行优化，这样时间复杂度就能降到 了. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int n;char ch;bool a[N], d[N];int main(){ ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; ch; a[i] = ch == 'F'; } int k, m = INT_MAX; for (int l = 1; l &lt;= n; l++) { memset(d, 0, sizeof(d)); bool sum = 0, flag = true; int cnt = 0; for (int i = 1; i &lt;= n; i++) { sum ^= d[i]; if (a[i] ^ sum) continue; if (i + l - 1 &gt; n) { flag = false; break; } sum ^= 1; d[i + l] ^= 1; cnt++; } if (flag) { if (m &gt; cnt) { m = cnt; k = l; } } } cout &lt;&lt; k &lt;&lt; \" \" &lt;&lt; m &lt;&lt; endl; return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"http://herveyb3b4.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"USACO","slug":"题解/USACO","permalink":"http://herveyb3b4.github.io/categories/%E9%A2%98%E8%A7%A3/USACO/"}],"tags":[{"name":"差分","slug":"差分","permalink":"http://herveyb3b4.github.io/tags/%E5%B7%AE%E5%88%86/"},{"name":"贪心","slug":"贪心","permalink":"http://herveyb3b4.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"安装Kali WSL","slug":"Misc/How-to-install-Kali-WSL","date":"2023-11-30T15:00:50.000Z","updated":"2025-03-02T06:35:20.470Z","comments":true,"path":"2023/11/30/Misc/How-to-install-Kali-WSL/","link":"","permalink":"http://herveyb3b4.github.io/2023/11/30/Misc/How-to-install-Kali-WSL/","excerpt":"false","text":"引言Kali WSL（Windows Subsystem for Linux）是在 Windows 环境下运行 Kali Linux 的一种方式，同时，WSL相比于Linux虚拟机能和Windows较好的进行文件系统的互通，非常适合用于学习。 步骤1. 开启 WSL 功能确保系统为 Windows 10 专业版及以上，然后按照以下步骤开启 WSL 功能： 打开控制面板 进入程序 -&gt; 启用或关闭 Windows 功能 勾选”适用于 Linux 的 Windows 子系统” 系统更新并重启生效 2. 安装 Kali WSL在 Windows 应用商店中搜索并下载适用于 Linux 的 Windows 子系统，选择 Kali 作为 Linux 发行版进行安装。 3. 升级到 WSL2由于版本问题，确保升级到 WSL2，执行以下命令： 1dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart wsl --set-version kali-linux 2 4. 安装完整版 Kali安装完成后，打开 Kali Linux ，根据设置用户名及密码。 重新启动 Kali Linux ，这时我们发现我们的 Kali Linux 还有很多工具没用安装。 执行以下命令安装 Kali 的完整版： 12sudo apt updatesudo apt install -y kali-linux-large 6. 配置图形化桌面并连接（可选）如果想要体验图形化界面，可以选择安装 Win-KeX 1sudo apt install -y kali-win-kex 打开 Window Mode (窗口模式) 1kex --win 如果你想要体验 Seamless Mode (无缝模式)，还需要额外安装 X410 安装完成后打开并勾选ACCESS CONTROL下的WSL2选项。 打开 Seamless Mode (窗口模式) 1kex --sl 详细教程:Protecting X410 Public Access for WSL2 via Windows Defender Firewall - X410.dev 7. 额外配置（可选）根据需求，可以配置 Windows Terminal，将 Kali 和 Win-KeX 整合进 Terminal。 以下是我的配置文件(仅留下 Kali WSL 相关配置) 1234567891011121314151617181920212223242526272829303132&#123; &quot;profiles&quot;: &#123; &quot;list&quot;: [ &#123; &quot;guid&quot;: &quot;&#123;46ca431a-3a87-5fb3-83cd-11ececc031d2&#125;&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;Kali Linux&quot;, &quot;icon&quot;: &quot;file:///c:/users/&lt;windows user&gt;/pictures/icons/kali-menu.png&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;startingDirectory&quot; : &quot;//wsl$/kali-linux/home/&lt;kali user&gt;&quot; &#125;, &#123; // &quot;guid&quot;: &quot;&#123;55ca431a-3a87-5fb3-83cd-11ececc031d2&#125;&quot;, &quot;hidden&quot;: false, &quot;icon&quot;: &quot;file:///c:/users/&lt;windows user&gt;/pictures/icons/kali-menu.png&quot;, &quot;name&quot;: &quot;Win-KeX Window Mode&quot;, &quot;commandline&quot;: &quot;wsl -d kali-linux kex --wtstart -s&quot;, &quot;startingDirectory&quot; : &quot;//wsl$/kali-linux/home/&lt;kali user&gt;&quot; &#125;, &#123; // &quot;guid&quot;: &quot;&#123;55ca431a-3a87-5fb3-83cd-11ececc031d2&#125;&quot;, &quot;hidden&quot;: false, &quot;icon&quot;: &quot;file:///c:/users/&lt;windows user&gt;/pictures/icons/kali-menu.png&quot;, &quot;name&quot;: &quot;Win-KeX Seamless Mode&quot;, &quot;commandline&quot;: &quot;wsl -d kali-linux kex --sl --wtstart -s&quot;, &quot;startingDirectory&quot; : &quot;//wsl$/kali-linux/home/&lt;kali user&gt;&quot; &#125;, ] &#125;&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://herveyb3b4.github.io/categories/CTF/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://herveyb3b4.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"如何使用Navicat连接WSL里的MySQL服务","slug":"Misc/How-to-use-Navicat-to-connect-to-MySQL-services-in-WSL","date":"2023-08-02T15:06:50.000Z","updated":"2025-03-02T06:28:46.102Z","comments":true,"path":"2023/08/02/Misc/How-to-use-Navicat-to-connect-to-MySQL-services-in-WSL/","link":"","permalink":"http://herveyb3b4.github.io/2023/08/02/Misc/How-to-use-Navicat-to-connect-to-MySQL-services-in-WSL/","excerpt":"false","text":"0 前言真的有人会干这么套娃的事情吗？ 原来是我啊，那没事了 究其原因，还是由于之前技术不精，在Windows系统上安装MySQL，结果MySQL炸了，而且还没办法卸载干净，这次想着既然VSCode可以与WSL连接，为何Navicat不能与WSL里的MySQL连接呢？ 而且照XCloudFance学长的说法：“你可以把WSL想象是里面的一台电脑，你的Windows也是一台独立的电脑”，那么navicat理论上应该可以与WSL中的MySQL连接。 于是，痛苦的两个小时配置之旅就开始了(中途还重装了一次WSL qwq) 1 前期准备1.1 安装Navicat自行Baidu&#x2F;Google&#x2F;Bing下载安装包 安装包打开后一路next即可 1.2 安装WSLBaidu&#x2F;Google&#x2F;Bing **注意:**记得将WSL版本设置为WSL2，本人使用的系统是Ubuntu22.04 1.3 在WSL中安装MySQL在WSL终端中输入 1sudo apt install mysql-server 即可，root及其余账户密码配置请自行百度 2 正式开始吧！2.1 找到WSL的IP地址首先，我们应该让Windows主机能够访问WSL，那么我们就应该先知道WSL的本地IP访问地址。 在Windows下打开终端(Power Shell)，使用如下命令查询： 1ipconfig 可以看到这样一行提示： 1234567以太网适配器 vEthernet (WSL): 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::85d4:3cdb:df1f:f6e1%42 IPv4 地址 . . . . . . . . . . . . : 172.30.224.1 子网掩码 . . . . . . . . . . . . : 255.255.240.0 默认网关. . . . . . . . . . . . . : 说明主机其实是能够访问到WSL的。 在WSL的终端中，使用ifconfig查询本地IP地址 1ifconfig 有可能需要使用如下指令安装net-tools： 1sudo apt install net-tools 安装成功后，运行ifconfig会输出类似下面的结果： 1234567891011121314151617eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.30.224.99 netmask 255.255.240.0 broadcast 172.30.239.255 inet6 fe80::215:5dff:fe99:f76a prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:15:5d:99:f7:6a txqueuelen 1000 (Ethernet) RX packets 104254 bytes 266388818 (266.3 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 69925 bytes 5218621 (5.2 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 5644 bytes 29799099 (29.7 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 5644 bytes 29799099 (29.7 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 第二行的172.30.224.99便是你的WSL的本地IP地址。 2.2 设置MySQL被局域网访问这时我们可以试着用Navicat连接一下刚才获得IP地址的WSL的MySQL服务，发现Navicat显示连接失败，这是因为我们未设置MySQL能被局域网访问。 进入MySQL中，修改账户的访问权限： 123456mysql -u root -p &lt;password&gt;mysql-&gt;use mysqlmysql-&gt;update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;;mysql-&gt;grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; with grant option;mysql-&gt;flush privileges;mysql-&gt;exit; 找到MySQL的配置文件进行修改: 1sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 在mysqld.cnf中，找到这样一行配置： 1bind-address = 127.0.0.1 修改为： 1bind-address = 0.0.0.0 保存后重启MySQL： 1sudo /etc/init.d/mysql restart 可以通过netstat -aptn检查MySQL的状态 12345(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)Active Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN - 2.3 设置Ubuntu防火墙此时我们还是无法连接，还需关闭Ubuntu的防火墙 1sudo ufw enable #开启 在WSL环境下，可能会得到如下提示： 123456789101112131415161718192021222324Traceback (most recent call last): File &quot;/usr/lib/python3/dist-packages/ufw/util.py&quot;, line 427, in under_ssh ppid = get_ppid(pid) File &quot;/usr/lib/python3/dist-packages/ufw/util.py&quot;, line 421, in get_ppid return int(ppid)ValueError: invalid literal for int() with base 10: &#x27;S&#x27;During handling of the above exception, another exception occurred:Traceback (most recent call last): File &quot;/usr/sbin/ufw&quot;, line 138, in &lt;module&gt; not ui.continue_under_ssh(): File &quot;/usr/lib/python3/dist-packages/ufw/frontend.py&quot;, line 901, in continue_under_ssh if self.backend.do_checks and ufw.util.under_ssh(): # pragma: no cover File &quot;/usr/lib/python3/dist-packages/ufw/util.py&quot;, line 457, in under_ssh return under_ssh(ppid) File &quot;/usr/lib/python3/dist-packages/ufw/util.py&quot;, line 457, in under_ssh return under_ssh(ppid) File &quot;/usr/lib/python3/dist-packages/ufw/util.py&quot;, line 457, in under_ssh return under_ssh(ppid) [Previous line repeated 1 more time] File &quot;/usr/lib/python3/dist-packages/ufw/util.py&quot;, line 434, in under_ssh raise ValueError(err_msg)ValueError: Couldn&#x27;t find parent pid for &#x27;3129&#x27; 这是因为/usr/lib/python3/dist-packages/ufw/util.py中有一行Python出现错误 更正方法是进入中： 1sudo vim /usr/lib/python3/dist-packages/ufw/util.py 将 1ppid = open(name).readlines()[0].split(&#x27;)&#x27;)[1].split()[1] 改为 1ppid = open(name).readlines()[0].rsplit(&#x27;)&#x27;,1)[1].split()[1] 即可 之后添加允许访问的端口3306并重载生效即可 12sudo ufw allow 3306sudo ufw reload 完成后查看 1sudo ufw status 得到如下结果即为成功 123456Status: activeTo Action From-- ------ ----3306 ALLOW Anywhere3306 (v6) ALLOW Anywhere (v6) 这时再使用Navicat访问，即可连接上WSL的MySQL服务。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://herveyb3b4.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://herveyb3b4.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"博客搭建教程","slug":"Misc/Build-Your-Blog","date":"2020-08-13T04:57:01.000Z","updated":"2025-03-01T15:25:30.885Z","comments":true,"path":"2020/08/13/Misc/Build-Your-Blog/","link":"","permalink":"http://herveyb3b4.github.io/2020/08/13/Misc/Build-Your-Blog/","excerpt":"false","text":"0 前言建这个博客踩了好多坑QWQ 1 安装1.1 安装Git和Node.js这没什么好说的吧… 安装完成后打开cmd通过以下两行命令检测是否安装成功 12git --versionnpm --version 1.2 更换国内镜像源如果您觉得网速够快可以选择跳过此步 1npm config set registry https://registry.npm.taobao.org 1.3 安装Hexo上一步不做的话这一步会慢得让你怀疑人生 1npm install -g hexo-cli 2 创建2.1 创建本地Blog新建一个空文件夹并进入 右键 -&gt; “Git Bash Here” 输入以下命令 1hexo init 2.2 进行本地预览继续在命令行中输入下列代码 12hexo ghexo s 之后进入打开浏览器http://localhost:4000就可以查看自己的Blog了 3 美化3.1 下载主题在GitHub中查找hexo-theme 选择一个自己喜欢的主题并clone或下载zip包解压到主目录&#x2F;themes中 3.1.1 yilia这里以yilia为例 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 3.1.2 Material 注意:使用Material主题最好用1.5.2版，最新版会一直报错 这里以Material为例 12cd themesgit clone https://github.com/viosey/hexo-theme-material.git material 3.1.3 Fluid 以下引用自Fluid官方文档 Hexo 5.0.0 版本以上，推荐通过 npm 直接安装 1npm install --save hexo-theme-fluid 3.2 使用主题3.2.1 yilia修改主目录下的 _config.yml 文件的 theme值为yilia。 1theme: yilia 复制 themes&#x2F;yilia 目录下_config.template.yml 为 _config.yml 3.2.2 Material修改主目录下的 _config.yml 文件的 theme值为material。 1theme: material 复制 themes&#x2F;material 目录下_config.template.yml 为 _config.yml 3.2.3 Fluid修改主目录下的 _config.yml 文件的 theme值为fluid。 1theme: fluid 然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。 3.3 更改语言修改主目录下的 _config.yml 文件的 language值为zh-CN。 1language: zh-CN 3.4 站内搜索3.4.1 yilia &#x2F; Material安装 hexo-generator-search 插件。 1npm install hexo-generator-searchdb --save 修改theme&#x2F;主题名 目录 _config.yml 中的 search值 123search: use: local swiftype_key: 然后在主目录的_config.yml文件中添加 123search: path: search.xml field: all 3.4.2 Fluid修改主目录的 _config.fluid.yml 中的 search值 123456789101112131415161718192021# 搜索功能，基于 hexo-generator-search 插件，若已安装其他搜索插件请关闭此功能，以避免生成多余的索引文件# Search feature, based on hexo-generator-search. If you have installed other search plugins, please disable this feature to avoid generating redundant index filessearch: enable: true # 搜索索引文件的路径，可以是相对路径或外站的绝对路径 # Path for search index file, it can be a relative path or an absolute path path: /local-search.xml # 文件生成在本地的位置，必须是相对路径 # The location where the index file is generated locally, it must be a relative location generate_path: /local-search.xml # 搜索的范围 # Search field # Options: post | page | all field: post # 搜索是否扫描正文 # If true, search will scan the post content content: true 4 部署到前一步本地的博客基本上就建好了，接下来就是将其部署在服务器上 4.1 连接Git仓库首先在GitHub注册一个账号,建立用户名.github.io的项目 接着打开Git Bash，输入下列命令 12git config --global user.name &quot;用户名&quot;git config --global user.email &quot;注册邮箱&quot; 4.2 添加密钥在Git Bash中继续输入下列命令生成SSH密钥 1ssh-keygen -t rsa -C &quot;注册邮箱&quot; 查看密钥 1cat ~/.ssh/id_rsa.pub 将输出的内容复制到SSH and GPG keys里 4.3 提交部署安装hexo-deployer-git 1npm install hexo-deployer-git --save 配置主目录的_config.yml文件 1234deploy: type: git repo: 仓库地址 branch: master 部署到GitHub 1hexo d 访问https:&#x2F;&#x2F;用户名.github.io&#x2F;","categories":[{"name":"随笔","slug":"随笔","permalink":"http://herveyb3b4.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://herveyb3b4.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}],"categories":[{"name":"《30天自制操作系统》学习笔记","slug":"《30天自制操作系统》学习笔记","permalink":"http://herveyb3b4.github.io/categories/%E3%80%8A30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"CTF","slug":"CTF","permalink":"http://herveyb3b4.github.io/categories/CTF/"},{"name":"WriteUp","slug":"CTF/WriteUp","permalink":"http://herveyb3b4.github.io/categories/CTF/WriteUp/"},{"name":"算法","slug":"算法","permalink":"http://herveyb3b4.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"算法/图论","permalink":"http://herveyb3b4.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"},{"name":"题解","slug":"题解","permalink":"http://herveyb3b4.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"USACO","slug":"题解/USACO","permalink":"http://herveyb3b4.github.io/categories/%E9%A2%98%E8%A7%A3/USACO/"},{"name":"数据结构","slug":"数据结构","permalink":"http://herveyb3b4.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"随笔","slug":"随笔","permalink":"http://herveyb3b4.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://herveyb3b4.github.io/tags/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Misc","slug":"Misc","permalink":"http://herveyb3b4.github.io/tags/Misc/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://herveyb3b4.github.io/tags/Tarjan/"},{"name":"边双连通分量","slug":"边双连通分量","permalink":"http://herveyb3b4.github.io/tags/%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"点双连通分量","slug":"点双连通分量","permalink":"http://herveyb3b4.github.io/tags/%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"强连通分量","slug":"强连通分量","permalink":"http://herveyb3b4.github.io/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"圆方树","slug":"圆方树","permalink":"http://herveyb3b4.github.io/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"name":"割边","slug":"割边","permalink":"http://herveyb3b4.github.io/tags/%E5%89%B2%E8%BE%B9/"},{"name":"割点","slug":"割点","permalink":"http://herveyb3b4.github.io/tags/%E5%89%B2%E7%82%B9/"},{"name":"Kruskal","slug":"Kruskal","permalink":"http://herveyb3b4.github.io/tags/Kruskal/"},{"name":"Prim","slug":"Prim","permalink":"http://herveyb3b4.github.io/tags/Prim/"},{"name":"Floyd-Warshall","slug":"Floyd-Warshall","permalink":"http://herveyb3b4.github.io/tags/Floyd-Warshall/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://herveyb3b4.github.io/tags/Dijkstra/"},{"name":"Bellman-Ford","slug":"Bellman-Ford","permalink":"http://herveyb3b4.github.io/tags/Bellman-Ford/"},{"name":"SPFA","slug":"SPFA","permalink":"http://herveyb3b4.github.io/tags/SPFA/"},{"name":"树的直径","slug":"树的直径","permalink":"http://herveyb3b4.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"树的重心","slug":"树的重心","permalink":"http://herveyb3b4.github.io/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"最近公共祖先(LCA)","slug":"最近公共祖先-LCA","permalink":"http://herveyb3b4.github.io/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-LCA/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://herveyb3b4.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"逆序对","slug":"逆序对","permalink":"http://herveyb3b4.github.io/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"分治","slug":"分治","permalink":"http://herveyb3b4.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"归并排序","slug":"归并排序","permalink":"http://herveyb3b4.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"树状数组","slug":"树状数组","permalink":"http://herveyb3b4.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"线段树","slug":"线段树","permalink":"http://herveyb3b4.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"权值树状数组","slug":"权值树状数组","permalink":"http://herveyb3b4.github.io/tags/%E6%9D%83%E5%80%BC%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"权值线段树","slug":"权值线段树","permalink":"http://herveyb3b4.github.io/tags/%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"字符串","slug":"字符串","permalink":"http://herveyb3b4.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Trie","slug":"Trie","permalink":"http://herveyb3b4.github.io/tags/Trie/"},{"name":"搜索","slug":"搜索","permalink":"http://herveyb3b4.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://herveyb3b4.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"洪水填充","slug":"洪水填充","permalink":"http://herveyb3b4.github.io/tags/%E6%B4%AA%E6%B0%B4%E5%A1%AB%E5%85%85/"},{"name":"RMQ","slug":"RMQ","permalink":"http://herveyb3b4.github.io/tags/RMQ/"},{"name":"笛卡尔树","slug":"笛卡尔树","permalink":"http://herveyb3b4.github.io/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/"},{"name":"The Method of Four Russians","slug":"The-Method-of-Four-Russians","permalink":"http://herveyb3b4.github.io/tags/The-Method-of-Four-Russians/"},{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://herveyb3b4.github.io/tags/CDQ%E5%88%86%E6%B2%BB/"},{"name":"悬线法","slug":"悬线法","permalink":"http://herveyb3b4.github.io/tags/%E6%82%AC%E7%BA%BF%E6%B3%95/"},{"name":"障碍点法","slug":"障碍点法","permalink":"http://herveyb3b4.github.io/tags/%E9%9A%9C%E7%A2%8D%E7%82%B9%E6%B3%95/"},{"name":"离散化","slug":"离散化","permalink":"http://herveyb3b4.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"差分","slug":"差分","permalink":"http://herveyb3b4.github.io/tags/%E5%B7%AE%E5%88%86/"},{"name":"贪心","slug":"贪心","permalink":"http://herveyb3b4.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"环境配置","slug":"环境配置","permalink":"http://herveyb3b4.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://herveyb3b4.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}